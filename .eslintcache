[{"/mnt/d/code/projects/newpathfinding/src/index.js":"1","/mnt/d/code/projects/newpathfinding/src/reportWebVitals.js":"2","/mnt/d/code/projects/newpathfinding/src/App.js":"3","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Board/Board.js":"4","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Node/Node.js":"5","/mnt/d/code/projects/newpathfinding/src/Pathfinding/pathfinding.js":"6","/mnt/d/code/projects/newpathfinding/src/main.js":"7","/mnt/d/code/projects/newpathfinding/src/Sorting/Sorting.js":"8","/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Bar.js":"9","/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Algorithms/topdownmergesort.js":"10"},{"size":500,"mtime":1610173509676,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1610173509703,"results":"13","hashOfConfig":"12"},{"size":127,"mtime":1612141681660,"results":"14","hashOfConfig":"12"},{"size":16765,"mtime":1612911250240,"results":"15","hashOfConfig":"12"},{"size":838,"mtime":1611540849993,"results":"16","hashOfConfig":"12"},{"size":4811,"mtime":1610898133541,"results":"17","hashOfConfig":"12"},{"size":640,"mtime":1612141857017,"results":"18","hashOfConfig":"12"},{"size":193,"mtime":1612142679471,"results":"19","hashOfConfig":"12"},{"size":11808,"mtime":1613610340937,"results":"20","hashOfConfig":"12"},{"size":1621,"mtime":1613029106535,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"ap0dwy",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"24"},"/mnt/d/code/projects/newpathfinding/src/index.js",[],["47","48"],"/mnt/d/code/projects/newpathfinding/src/reportWebVitals.js",[],"/mnt/d/code/projects/newpathfinding/src/App.js",[],"/mnt/d/code/projects/newpathfinding/src/Pathfinding/Board/Board.js",["49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75"],"import React, { Component } from 'react'\nimport pathfinder from '../pathfinding.js';\nimport Node from '../Node/Node';\n\nimport './board.css'\nvar BOARD_WIDTH = 41\nvar BOARD_HEIGHT = 11\nvar START_POS = { x: 2, y: Math.floor(BOARD_HEIGHT / 2) }\nvar END_POS = { x: BOARD_WIDTH - 3, y: Math.floor(BOARD_HEIGHT / 2) }\n\nexport default class Board extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            gridComp: [],\n            mouseIsPressed: false,\n            lastPressed: null,\n            lastSwitched: null,\n\n        }\n        this.pathfinder = new pathfinder()\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n        return false\n    }\n    accessRef(ele) {\n        return this.state.gridComp[ele.y][ele.x].ref.current\n    }\n    createRecursiveMaze() {\n        let resettimeout = this.resetGrid()\n        let grid = this.recursiveDivisionGrid()\n        console.log(grid);\n        setTimeout(() => {\n\n\n            for (let x = 0; x < grid.length; x++) {\n                setTimeout(() => {\n                    if (this.state.grid[grid[x].y][grid[x].x].passage) {\n                        console.log(\"p\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        if (this.state.grid[grid[x].y][grid[x].x].extra) {\n                            console.log(\"e\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        }\n                        console.log(this.state.grid[grid[x].y][grid[x].x].horizontal);\n                    } else {\n\n                    }\n                    this.makeWall(grid[x].x, grid[x].y)\n\n\n                }, x * 5);\n            }\n        }, resettimeout);\n    }\n    animateRecursiveGrid(speed = 5) {\n        let grid = this.recursiveDivisionGrid()\n        for (let x = 0; x < grid.length; x++) {\n            setTimeout(() => {\n                this.makeWall(grid[x].x, grid[x].y)\n            }, x * (speed * 5));\n        }\n    }\n    aStarSolve() {\n        this.removePathOpenCurrent()\n        let test = this.pathfinder.solveAstar(this.state.grid, START_POS, END_POS)\n\n        this.animateastar(test[0], test[1], 5)\n\n    }\n    animateastar(path, open, speed = 1) {\n        for (let x = 0; x < open.length; x++) {\n            setTimeout(() => {\n                this.accessRef(open[x]).className += \" current\"\n                setTimeout(() => {\n\n                    if (open[x - 1]) {\n                        this.accessRef(open[x - 1]).className = this.accessRef(open[x - 1]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x - 1]).className += \" open\"\n                    }\n                    if (x === open.length - 1) {\n                        this.accessRef(open[x]).className = this.accessRef(open[x]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x]).className += \" open\"\n                    }\n                }, 0);\n\n\n\n            }, x * (speed * 5));\n        }\n        if (path.length == 0) {\n            setTimeout(() => {\n                for (let x = 0; x < open.length; x++) {\n                    this.accessRef(open[x]).className += \" noPath\"\n                }\n\n            }, open.length * (speed) + 100);\n        }\n        setTimeout(() => {\n            for (let x = 0; x < path.length; x++) {\n                setTimeout(() => {\n                    console.log(\"test\");\n                    if (!path[x].start && !path[x].end) {\n                        this.accessRef(path[x]).className = \"node path\"\n                    }\n                }, x * (speed * 7.5));\n\n            }\n        }, (open.length * (speed * 5)) + 100);\n\n\n\n\n\n\n    }\n    resetGrid(wipe = false) {\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let firstNonNode = null\n        let lastNonNode = null\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (firstNonNode == null || x < firstNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        firstNonNode = x\n                    }\n                }\n                if (lastNonNode == null || x > lastNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        lastNonNode = x\n                    }\n                }\n                if (this.state.grid[y][x].wall) {\n                    this.state.grid[y][x].wall = false\n                }\n                if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                    continue\n                }\n                if (!wipe) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n\n            }\n        }\n        if (firstNonNode == null) {\n            firstNonNode = 0\n        }\n        if (lastNonNode == null) {\n            lastNonNode = this.state.grid[0].length - 1\n        }\n        if (wipe) {\n            for (let x = firstNonNode; x <= lastNonNode; x++) {\n\n                // console.log(x);\n                setTimeout(() => {\n                    for (let y = 0; y < this.state.grid.length; y++) {\n                        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                            this.accessRef(this.state.grid[y][x]).className += \" wipe\"\n\n                        } else {\n                            this.accessRef(this.state.grid[y][x]).className = \"node wipe\"\n                        }\n                        setTimeout(() => {\n                            this.accessRef(this.state.grid[y][x]).className = this.accessRef(this.state.grid[y][x]).className.replace(\" wipe\", \"\")\n                        }, 300);\n                    }\n                }, 45 * x);\n            }\n\n            return (45 * this.state.grid[0].length) + 300\n        }\n        return 0\n\n    }\n    removePathOpenCurrent() {\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (this.accessRef(this.state.grid[y][x]).className.includes(\"path\") || this.accessRef(this.state.grid[y][x]).className.includes(\"open\") || this.accessRef(this.state.grid[y][x]).className.includes(\"current\")) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n            }\n        }\n    }\n    resetStartEnd(reset) {\n\n        // START_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // START_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n\n        // END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // while (END_POS.x == START_POS.x && START_POS.y == END_POS.y) {\n        //     END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        //     END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // }\n        if (reset) {\n            this.state.grid[START_POS.y][START_POS.x].start = true\n            this.state.grid[END_POS.y][END_POS.x].end = true\n            this.accessRef(START_POS).className = \"node start\"\n            this.accessRef(END_POS).className = \"node end\"\n        }\n        console.log(START_POS);\n        console.log(END_POS);\n    }\n    componentDidMount() {\n        console.log(new pathfinder().astar);\n        this.resetStartEnd()\n        let grids = this.createBlankGrid()\n        console.log(grids[0]);\n        this.setState({ grid: grids[0], gridComp: grids[1] })\n    }\n    render() {\n        return (\n            <div className=\"container\">\n                <button onClick={() => this.createRecursiveMaze()}>grid</button>\n                <button onClick={() => this.aStarSolve()}>solve</button>\n                <button onClick={() => this.resetGrid(true)}>reset</button>\n                <div className=\"grid\">\n                    {this.state.gridComp.map((row, rowid) =>\n                        <div id={rowid} className=\"row\"> {row.map((item) => (item.node))} </div>\n                    )\n                    } </div>\n            </div>\n        )\n    }\n    handleGridItemChange(ref, x, y) {\n        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n            return\n        }\n        let className = ref.current.className\n        switch (className) {\n            case \"node wall\":\n                this.makeNode(x, y)\n                break;\n            default:\n                this.makeWall(x, y)\n                break;\n        }\n\n\n    }\n    isStartOrEnd(x, y) {\n        //console.log(x, y);\n        return this.state.grid[y][x].start || this.state.grid[y][x].end\n    }\n    makeWall(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = true\n        this.accessRef(this.state.grid[y][x]).className = \"node wall\"\n    }\n    makeNode(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = false\n        this.accessRef(this.state.grid[y][x]).className = \"node\"\n    }\n    handleMouseDown(ref, x, y) {\n        if (this.nodeEquals({ x, y }, START_POS)) {\n            console.log(\"start\");\n            this.state.lastPressed = \"start\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        if (this.nodeEquals({ x, y }, END_POS)) {\n            console.log(\"end\");\n            this.state.lastPressed = \"end\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        this.setState({ mouseIsPressed: true })\n\n        this.handleGridItemChange(ref, x, y, true)\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    setStartEnd(x, y) {\n        switch (this.state.lastPressed) {\n            case \"start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = { x, y }\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = { x, y }\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n        switch (this.accessRef(this.state.lastSwitched).className) {\n            case \"node start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = this.state.lastSwitched\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"node end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = this.state.lastSwitched\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n    }\n    handleMouseEnter(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            console.log(x, y);\n            console.log(this.state.lastSwitched);\n            this.accessRef(this.state.lastSwitched).className = this.accessRef({ x, y }).className\n            ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastSwitched = { x, y }\n        }\n        if (!this.state.mouseIsPressed) {\n            return\n        }\n        this.handleGridItemChange(ref, x, y)\n        // ref.current.className.includes(\"wall\") ? ref.current.className = \"node\" : ref.current.className = \"node wall\"\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    handleMouseUp(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            //ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastPressed = null\n            this.state.lastSwitched = null\n        }\n        this.setState({ mouseIsPressed: false })\n        console.log(\"mouse up\");\n\n    }\n    createBlankGrid() {\n        let grid = [];\n        let gridcomp = []\n        for (let y = 0; y < Math.floor(BOARD_HEIGHT); y++) {\n            let row = [];\n            let rowcomp = []\n            for (let x = 0; x < BOARD_WIDTH; x++) {\n                let curref = React.createRef()\n                let type = this.nodeEquals({ x: x, y: y }, START_POS) ? \" start\" : this.nodeEquals({ x: x, y: y }, END_POS) ? \" end\" : \"\"\n                let curnode = (< Node x={x}\n                    y={y}\n                    mouseIsPressed={this.state.mouseIsPressed}\n                    onMouseDown={\n                        (ref) => this.handleMouseDown(ref, x, y)}\n                    onMouseEnter={\n                        (ref) => this.handleMouseEnter(ref, x, y)}\n                    onMouseUp={\n                        (ref) => this.handleMouseUp(ref, x, y)}\n                    refpass={curref}\n                    type={\"node\" + type}\n                >\n                </Node>)\n                let curitem = {\n                    x: x,\n                    y: y,\n                    f: Infinity,\n                    h: 0,\n                    g: 0,\n                    start: type == \" start\",\n                    end: type == \" end\",\n                    wall: false\n                }\n                row.push(curitem)\n                let curcomp = {\n                    x: x,\n                    y: y,\n                    node: curnode,\n                    ref: curref\n                }\n                rowcomp.push(curcomp)\n            }\n            grid.push(row)\n            gridcomp.push(rowcomp)\n        }\n        let test = []\n        test.push(grid)\n        test.push(gridcomp)\n        return test\n    }\n    recursiveDivisionGrid() {\n\n        let width = this.state.grid[0].length\n        let height = this.state.grid.length\n        let cells = []\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (y == 0 || y == height - 1) {\n                    cells.push({ x, y })\n                    //this.makeWall(x, y)\n                }\n            }\n\n            //this.makeWall(0, y)\n            cells.push({ x: 0, y })\n            //this.makeWall(width - 1, y)\n            cells.push({ x: width - 1, y })\n\n        }\n        return cells.concat(this.divide(false, 2, width - 3, 2, height - 3))\n\n    }\n    divide(h, minX, maxX, minY, maxY, animationCells = []) {\n        //if (maxY - minY > maxX - minX || (maxY - minY == maxX - minX) && Math.floor(Math.random() * 2) == 1) {\n        if (h) {\n            if (maxX - minX < 1) {\n                return animationCells\n            }\n\n            var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2\n            animationCells = animationCells.concat(this.addHWall(minX, maxX, y))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, minY, y - 2))\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, y + 2, maxY))\n        } else {\n            if (maxY - minY < 1) {\n                return animationCells\n            }\n\n            var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2\n            animationCells = animationCells.concat(this.addVWall(minY, maxY, x))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, x - 2, minY, maxY))\n            animationCells = animationCells.concat(this.divide(!h, x + 2, maxX, minY, maxY))\n        }\n        return animationCells\n\n    }\n    addHWall(minX, maxX, y) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        var hole2 = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        console.log(minX, maxX, hole);\n        hole2 = 999\n        for (var i = minX - 1; i <= maxX + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(i, y)\n                continue\n            }\n            cells.push({ x: i, y: y })\n        }\n        return cells\n    }\n\n    addVWall(minY, maxY, x) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1\n\n        var hole2 = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\n        console.log(minY, maxY, hole);\n        hole2 = 999\n        for (var i = minY - 1; i <= maxY + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(x, i)\n                continue\n            }\n            cells.push({ x: x, y: i })\n        }\n        return cells\n    }\n\n    randomNumber(min, max) {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Node/Node.js",["76"],"import React, { Component, createRef } from 'react'\nimport './node.css'\nexport default class Node extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            x: props.x,\n            y: props.y,\n            id: +props.x + \"|\" + props.y,\n            class: props.type,\n            ref: props.refpass,\n        }\n        \n    }\n    render() {\n        return (\n            <div id={this.state.id} className={this.state.class}\n                ref={this.state.ref}\n                onMouseDown={() => this.props.onMouseDown(this.state.ref,this.state.x,this.state.y)}\n                onMouseEnter={() => this.props.onMouseEnter(this.state.ref,this.state.x,this.state.y)}\n                onMouseUp={() => this.props.onMouseUp(this.state.ref,this.state.x,this.state.y)}>\n            </div>\n        )\n    }\n}\n","/mnt/d/code/projects/newpathfinding/src/Pathfinding/pathfinding.js",["77"],"export default class pathfinder {\n    constructor() {\n        this.astar = null\n    }\n    solveAstar(grid, start, end) {\n        this.astar = new astar(start, end, grid)\n        return this.astar.solve()\n    }\n\n\n}\n\nclass astar {\n    constructor(start, end, grid) {\n        this.START_POS = start\n        this.END_POS = end\n        this.grid = grid;\n        console.log(start);\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n    }\n    solve() {\n        let open = []\n        let openAnimationCells = []\n        let closed = []\n        console.log(this.START_POS);\n        let start = this.grid[this.START_POS.y][this.START_POS.x]\n        let end = this.grid[this.END_POS.y][this.END_POS.x]\n        console.log(this.grid);\n        start.f = 0\n        start.g = 0\n        start.start = true\n        end.end = true\n        start.parent = null\n        open.push(start)\n        while (open.length > 0) {\n            open.sort((a, b) => (a.f > b.f) ? 1 : -1)\n\n            if (open.length > 5) {\n                //return\n            }\n            let cur = open[0]\n            open = open.slice(1)\n            let neighbours = this.getNeighbours(cur)\n            for (let i = 0; i < neighbours.length; i++) {\n                let cn = neighbours[i]\n                let clone = JSON.parse(JSON.stringify(cur))\n                cn.parent = clone\n                if (cn.wall) {\n                    continue\n                }\n                // fin conditon\n                if (cn.end) {\n                    console.log(\"finished\");\n                    let cc = cn\n                    let path = []\n                    while (cc != null && !(cc.start)) {\n                        path.push(cc)\n                        cc = cc.parent\n                    }\n                    path.reverse()\n\n                    return [path, openAnimationCells]\n\n\n                }\n                let g = cur.g\n                cn.g = cn.diagonal ? g + 2 : g + 1\n                cn.h = this.heuristic(cn, end)\n                cn.f = cn.g + cn.h\n\n                let obj2 = null\n                let indexclosed = null\n                for (let x = 0; x < closed.length; x++) {\n\n                    if (this.nodeEquals(closed[x], cn)) {\n                        obj2 = closed[x]\n                        indexclosed = x\n                        break\n                    }\n                }\n                if (obj2 != null) {\n                    if (cn.g < obj2.g) {\n                        open.push(cn.g)\n                    }\n                    continue\n                }\n                let obj = null\n                let openindex = null\n                for (let x = 0; x < open.length; x++) {\n\n                    if (this.nodeEquals(open[x], cn)) {\n                        obj = open[x]\n                        openindex = x\n                        break\n                    }\n                }\n                if (obj != null) {\n                    //console.log(\"switched\", this.accessRef(open[openindex]));\n                    if (cn.g < obj.g) {\n                        openAnimationCells.push(cn)\n                        open[openindex] = cn\n                    }\n                    continue\n                }\n                open.push(cn)\n                openAnimationCells.push(cn)\n\n\n\n\n            }\n            closed.push(cur)\n        }\n        return [[], openAnimationCells]\n    }\n    heuristic(pos0, pos1) {\n        var a = pos0.x - pos1.x\n        var b = pos0.y - pos1.y\n\n        return Math.sqrt(a * a + b * b)\n    }\n    getNeighbours(node, diagonal = false) {\n        let grid = this.grid\n        var ret = [];\n        var x = node.y\n        var y = node.x\n\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y]);\n        }\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y]);\n        }\n        if (grid[x][y - 1]) {\n            ret.push(grid[x][y - 1]);\n        }\n        if (grid[x][y + 1]) {\n            ret.push(grid[x][y + 1]);\n        }\n        let ret2 = []\n        if (diagonal) {\n\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret2.push(grid[x + 1][y + 1]);\n            }\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret2.push(grid[x + 1][y - 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret2.push(grid[x - 1][y + 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret2.push(grid[x - 1][y - 1]);\n            }\n            for (let i = 0; i < ret2.length; i++) {\n                ret2[i].diagonal = true;\n            }\n        }\n        // for (let x = 0; x < ret.length; x++) {\n        //     ret[x].parent = null\n        // }\n        return ret.concat(ret2);\n    }\n\n}","/mnt/d/code/projects/newpathfinding/src/main.js",[],"/mnt/d/code/projects/newpathfinding/src/Sorting/Sorting.js",[],"/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Bar.js",["78","79","80","81","82","83","84","85","86","87","88"],"/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Algorithms/topdownmergesort.js",["89","90","91"],"export function mergeSort(\n    array,\n    start,\n    end,\n    workArray,\n    anims\n) {\n    if (start == end) {\n        return\n    }\n    const initialStart = start\n    const initialEnd = end\n    const middle = Math.floor((start + end) / 2)\n    anims.push({ type: \"split\", left: [start, middle], right: [middle + 1, end], middle: [middle, middle + 1] })//initial split\n    mergeSort(workArray, start, middle, array, anims);\n    mergeSort(workArray, middle + 1, end, array, anims);\n    anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n    merge(array, start, middle, end, workArray, anims);\n}\nfunction merge(\n    array,\n    start,\n    middle,\n    end,\n    workArray,\n    anims\n) {\n\n    let k = start\n    let i = start\n    let j = middle + 1\n    //perform the merge in sort order\n    while (i <= middle && j <= end) {\n        //compare\n        anims.push({ type: \"compare\", vals: [i, j, (workArray[i] <= workArray[j]) ? i : j] })\n        if (workArray[i] <= workArray[j]) {\n            anims.push({ type: \"change\", vals: [k, workArray[i]] });\n            array[k++] = workArray[i++];\n        } else {\n            anims.push({ type: \"change\", vals: [k, workArray[j]] });\n            array[k++] = workArray[j++];\n        }\n    }\n\n\n    //pick up the last element(s)\n    while (i <= middle) {\n        anims.push({ type: \"change\", vals: [k, workArray[i], i] });\n        array[k++] = workArray[i++];\n    }\n    while (j <= end) {\n        anims.push({ type: \"change\", vals: [k, workArray[j], j] });\n        array[k++] = workArray[j++];\n    }\n}",{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","severity":1,"message":"97","line":93,"column":25,"nodeType":"98","messageId":"99","endLine":93,"endColumn":27},{"ruleId":"100","severity":1,"message":"101","line":140,"column":21,"nodeType":"102","endLine":140,"endColumn":42},{"ruleId":"100","severity":1,"message":"101","line":202,"column":13,"nodeType":"102","endLine":202,"endColumn":54},{"ruleId":"100","severity":1,"message":"101","line":203,"column":13,"nodeType":"102","endLine":203,"endColumn":50},{"ruleId":"100","severity":1,"message":"101","line":255,"column":9,"nodeType":"102","endLine":255,"endColumn":30},{"ruleId":"100","severity":1,"message":"101","line":262,"column":9,"nodeType":"102","endLine":262,"endColumn":30},{"ruleId":"100","severity":1,"message":"101","line":268,"column":13,"nodeType":"102","endLine":268,"endColumn":23},{"ruleId":"100","severity":1,"message":"101","line":269,"column":13,"nodeType":"102","endLine":269,"endColumn":23},{"ruleId":"100","severity":1,"message":"101","line":274,"column":13,"nodeType":"102","endLine":274,"endColumn":23},{"ruleId":"100","severity":1,"message":"101","line":275,"column":13,"nodeType":"102","endLine":275,"endColumn":23},{"ruleId":"103","severity":1,"message":"104","line":284,"column":9,"nodeType":"105","messageId":"106","endLine":296,"endColumn":10},{"ruleId":"100","severity":1,"message":"101","line":286,"column":17,"nodeType":"102","endLine":286,"endColumn":58},{"ruleId":"100","severity":1,"message":"101","line":288,"column":17,"nodeType":"102","endLine":288,"endColumn":58},{"ruleId":"100","severity":1,"message":"101","line":292,"column":17,"nodeType":"102","endLine":292,"endColumn":54},{"ruleId":"100","severity":1,"message":"101","line":294,"column":17,"nodeType":"102","endLine":294,"endColumn":54},{"ruleId":"103","severity":1,"message":"104","line":297,"column":9,"nodeType":"105","messageId":"106","endLine":309,"endColumn":10},{"ruleId":"100","severity":1,"message":"101","line":299,"column":17,"nodeType":"102","endLine":299,"endColumn":58},{"ruleId":"100","severity":1,"message":"101","line":301,"column":17,"nodeType":"102","endLine":301,"endColumn":58},{"ruleId":"100","severity":1,"message":"101","line":305,"column":17,"nodeType":"102","endLine":305,"endColumn":54},{"ruleId":"100","severity":1,"message":"101","line":307,"column":17,"nodeType":"102","endLine":307,"endColumn":54},{"ruleId":"100","severity":1,"message":"101","line":319,"column":13,"nodeType":"102","endLine":319,"endColumn":23},{"ruleId":"100","severity":1,"message":"101","line":333,"column":13,"nodeType":"102","endLine":333,"endColumn":23},{"ruleId":"100","severity":1,"message":"101","line":334,"column":13,"nodeType":"102","endLine":334,"endColumn":23},{"ruleId":"96","severity":1,"message":"97","line":368,"column":33,"nodeType":"98","messageId":"99","endLine":368,"endColumn":35},{"ruleId":"96","severity":1,"message":"97","line":369,"column":31,"nodeType":"98","messageId":"99","endLine":369,"endColumn":33},{"ruleId":"96","severity":1,"message":"97","line":396,"column":23,"nodeType":"98","messageId":"99","endLine":396,"endColumn":25},{"ruleId":"96","severity":1,"message":"97","line":396,"column":33,"nodeType":"98","messageId":"99","endLine":396,"endColumn":35},{"ruleId":"107","severity":1,"message":"108","line":1,"column":28,"nodeType":"109","messageId":"110","endLine":1,"endColumn":37},{"ruleId":"107","severity":1,"message":"111","line":81,"column":25,"nodeType":"109","messageId":"110","endLine":81,"endColumn":36},{"ruleId":"107","severity":1,"message":"112","line":2,"column":28,"nodeType":"109","messageId":"110","endLine":2,"endColumn":34},{"ruleId":"103","severity":1,"message":"104","line":37,"column":17,"nodeType":"105","messageId":"106","endLine":93,"endColumn":18},{"ruleId":"96","severity":1,"message":"97","line":43,"column":54,"nodeType":"98","messageId":"99","endLine":43,"endColumn":56},{"ruleId":"96","severity":1,"message":"113","line":63,"column":37,"nodeType":"98","messageId":"99","endLine":63,"endColumn":39},{"ruleId":"103","severity":1,"message":"104","line":103,"column":9,"nodeType":"105","messageId":"106","endLine":137,"endColumn":10},{"ruleId":"107","severity":1,"message":"114","line":109,"column":27,"nodeType":"109","messageId":"110","endLine":109,"endColumn":33},{"ruleId":"96","severity":1,"message":"97","line":109,"column":46,"nodeType":"98","messageId":"99","endLine":109,"endColumn":48},{"ruleId":"107","severity":1,"message":"115","line":116,"column":35,"nodeType":"109","messageId":"110","endLine":116,"endColumn":44},{"ruleId":"103","severity":1,"message":"104","line":150,"column":9,"nodeType":"105","messageId":"106","endLine":207,"endColumn":10},{"ruleId":"96","severity":1,"message":"97","line":156,"column":46,"nodeType":"98","messageId":"99","endLine":156,"endColumn":48},{"ruleId":"96","severity":1,"message":"113","line":176,"column":29,"nodeType":"98","messageId":"99","endLine":176,"endColumn":31},{"ruleId":"96","severity":1,"message":"97","line":8,"column":15,"nodeType":"98","messageId":"99","endLine":8,"endColumn":17},{"ruleId":"96","severity":1,"message":"97","line":17,"column":78,"nodeType":"98","messageId":"99","endLine":17,"endColumn":80},{"ruleId":"96","severity":1,"message":"97","line":17,"column":101,"nodeType":"98","messageId":"99","endLine":17,"endColumn":103},"no-native-reassign",["116"],"no-negated-in-lhs",["117"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-unused-vars","'createRef' is defined but never used.","Identifier","unusedVar","'indexclosed' is assigned a value but never used.","'useRef' is defined but never used.","Expected '!==' and instead saw '!='.","'higher' is assigned a value but never used.","'newHeight' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]