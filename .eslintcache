[{"/mnt/d/code/projects/newpathfinding/src/index.js":"1","/mnt/d/code/projects/newpathfinding/src/reportWebVitals.js":"2","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Board/Board.js":"3","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Node/Node.js":"4","/mnt/d/code/projects/newpathfinding/src/Pathfinding/pathfinding.js":"5","/mnt/d/code/projects/newpathfinding/src/main.js":"6","/mnt/d/code/projects/newpathfinding/src/Sorting/Sorting.js":"7","/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Bar.js":"8","/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Algorithms/topdownmergesort.js":"9","/mnt/d/code/projects/newpathfinding/src/Sidebar/SideOptions.js":"10"},{"size":508,"mtime":1614620034505,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1610173509703,"results":"13","hashOfConfig":"12"},{"size":19190,"mtime":1614618752732,"results":"14","hashOfConfig":"12"},{"size":839,"mtime":1614478049586,"results":"15","hashOfConfig":"12"},{"size":4811,"mtime":1614444361700,"results":"16","hashOfConfig":"12"},{"size":710,"mtime":1614482349684,"results":"17","hashOfConfig":"12"},{"size":193,"mtime":1612142679471,"results":"18","hashOfConfig":"12"},{"size":11808,"mtime":1613610340937,"results":"19","hashOfConfig":"12"},{"size":1621,"mtime":1613029106535,"results":"20","hashOfConfig":"12"},{"size":1875,"mtime":1614569249660,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"ap0dwy",{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"26"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"26"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"26"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"48","usedDeprecatedRules":"26"},"/mnt/d/code/projects/newpathfinding/src/index.js",[],"/mnt/d/code/projects/newpathfinding/src/reportWebVitals.js",[],["49","50"],"/mnt/d/code/projects/newpathfinding/src/Pathfinding/Board/Board.js",["51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81"],"import React, { Component } from 'react'\nimport pathfinder from '../pathfinding.js';\nimport Node from '../Node/Node';\n\nimport './board.scss'\nimport SideOptions from '../../Sidebar/SideOptions.js';\nvar BOARD_WIDTH = 41\nvar BOARD_HEIGHT = 15\nvar START_POS = { x: 2, y: Math.floor(BOARD_HEIGHT / 2) }\nvar END_POS = { x: BOARD_WIDTH - 3, y: Math.floor(BOARD_HEIGHT / 2) }\n\nexport default class Board extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            gridComp: [],\n            mouseIsPressed: false,\n            lastPressed: null,\n            lastSwitched: null,\n\n        }\n        this.pathfinder = new pathfinder()\n        this.speed = 10;\n        this.buttons = true;\n    }\n    speedCallback(sp) {\n        this.speed = sp;\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n        return false\n    }\n    accessRef(ele) {\n        return this.state.gridComp[ele.y][ele.x].ref.current\n    }\n    createRecursiveMaze() {\n        let resettimeout = this.resetGrid()\n        let grid = this.recursiveDivisionGrid()\n        console.log(grid);\n        setTimeout(() => {\n\n\n            for (let x = 0; x < grid.length; x++) {\n                setTimeout(() => {\n                    if (this.state.grid[grid[x].y][grid[x].x].passage) {\n                        console.log(\"p\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        if (this.state.grid[grid[x].y][grid[x].x].extra) {\n                            console.log(\"e\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        }\n                        console.log(this.state.grid[grid[x].y][grid[x].x].horizontal);\n                    } else {\n\n                    }\n                    this.makeWall(grid[x].x, grid[x].y)\n\n\n                }, x * this.speed);\n            }\n        }, resettimeout);\n    }\n    animateRecursiveGrid() {\n        let grid = this.recursiveDivisionGrid()\n        for (let x = 0; x < grid.length; x++) {\n            setTimeout(() => {\n                this.makeWall(grid[x].x, grid[x].y)\n            }, x * (this.speed * 3));\n        }\n    }\n    aStarSolve() {\n        console.log(this.buttons);\n        if(!this.buttons){\n            return;\n        }\n        this.removePathOpenCurrent()\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let test = this.pathfinder.solveAstar(this.state.grid, START_POS, END_POS)\n\n        this.animateastar(test[0], test[1], 5)\n\n    }\n    animateastar(path, open) {\n        for (let x = 0; x < open.length; x++) {\n            setTimeout(() => {\n                this.accessRef(open[x]).className += \" current\"\n                setTimeout(() => {\n\n                    if (open[x - 1]) {\n                        this.accessRef(open[x - 1]).className = this.accessRef(open[x - 1]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x - 1]).className += \" open\"\n                    }\n                    if (x === open.length - 1) {\n                        this.accessRef(open[x]).className = this.accessRef(open[x]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x]).className += \" open\"\n                    }\n                }, 0);\n\n\n\n            }, x * (this.speed * 5));\n        }\n        if (path.length == 0) {\n            setTimeout(() => {\n\n                for (let x = 0; x < open.length; x++) {\n                    setTimeout(() => {\n                        this.accessRef(open[x]).className += \" noPath\"\n                    }, x * (this.speed * 1));\n\n                }\n\n            }, (open.length * (this.speed * 5)));\n        }\n        setTimeout(() => {\n            for (let x = 0; x < path.length; x++) {\n                setTimeout(() => {\n                    console.log(\"test\");\n                    if (!path[x].start && !path[x].end) {\n                        this.accessRef(path[x]).className = \"node path\"\n                    }\n                }, x * (this.speed * 7.5));\n\n            }\n        }, (open.length * (this.speed * 5)) + 100);\n\n\n\n\n\n\n    }\n    resetGrid(wipe = false) {\n        this.buttons = false\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let firstNonNode = null\n        let lastNonNode = null\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (firstNonNode == null || x < firstNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        firstNonNode = x\n                    }\n                }\n                if (lastNonNode == null || x > lastNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        lastNonNode = x\n                    }\n                }\n                if (this.state.grid[y][x].wall) {\n                    this.state.grid[y][x].wall = false\n                }\n                if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                    continue\n                }\n                if (!wipe) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                    this.buttons= true;\n                }\n\n            }\n        }\n        if (firstNonNode == null) {\n            firstNonNode = 0\n        }\n        if (lastNonNode == null) {\n            lastNonNode = this.state.grid[0].length - 1\n        }\n        if (wipe) {\n            for (let x = firstNonNode; x <= lastNonNode; x++) {\n\n                // console.log(x);\n                setTimeout(() => {\n                    for (let y = 0; y < this.state.grid.length; y++) {\n\n                        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                            this.accessRef(this.state.grid[y][x]).className += \" wipe\"\n\n                        } else {\n                            this.accessRef(this.state.grid[y][x]).className = \"node wipe\"\n                        }\n                        setTimeout(() => {\n                            this.accessRef(this.state.grid[y][x]).className = this.accessRef(this.state.grid[y][x]).className.replace(\" wipe\", \"\")\n                        }, 300);\n                    }\n                }, 45 * x);\n            }\n\n            return (45 * this.state.grid[0].length) + 300\n        }\n        return 0\n\n    }\n    removePathOpenCurrent() {\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (this.accessRef(this.state.grid[y][x]).className.includes(\"path\") || this.accessRef(this.state.grid[y][x]).className.includes(\"open\") || this.accessRef(this.state.grid[y][x]).className.includes(\"current\")) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n            }\n        }\n    }\n    resetStartEnd(reset) {\n\n        // START_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // START_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n\n        // END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // while (END_POS.x == START_POS.x && START_POS.y == END_POS.y) {\n        //     END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        //     END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // }\n        if (reset) {\n            this.state.grid[START_POS.y][START_POS.x].start = true\n            this.state.grid[END_POS.y][END_POS.x].end = true\n            this.accessRef(START_POS).className = \"node start\"\n            this.accessRef(END_POS).className = \"node end\"\n        }\n        console.log(START_POS);\n        console.log(END_POS);\n    }\n    componentDidMount() {\n        console.log(new pathfinder().astar);\n        this.resetStartEnd()\n        let grids = this.createBlankGrid()\n        console.log(grids[0]);\n        this.setState({ grid: grids[0], gridComp: grids[1] })\n    }\n    componentWillUnmount(){\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n    }\n    render() {\n        return (\n            <div className=\"container\">\n                <div className=\"container2\">\n                    <div className=\"grid-options\">\n                        <div class=\"select\">\n                            <select name=\"slct\" id=\"slct\">\n                                <option value=\"AStar\">A* Search</option>\n                            </select>\n                        </div>\n                        <div className=\"header-button\" onClick={() => this.aStarSolve()}><span>Solve</span></div>\n                        <div class=\"select\">\n                            <select name=\"slct\" id=\"slct\">\n                                <option value=\"RecDiv\">Recursive Division</option>\n                            </select>\n                        </div>\n                        <div className=\"header-button\" onClick={() => this.createRecursiveMaze()}><span>Create</span></div>\n                        <div className=\"header-button\" onClick={() => {\n                            setTimeout(() => {\n                                this.buttons = true;\n                                console.log(this.buttons);\n                            }, this.resetGrid(true));\n                        }}><span>RESET GRID</span></div>\n\n                    </div>\n                    <SideOptions solve={() => this.aStarSolve()}\n                        speed={(sp) => { this.speedCallback(sp) }}\n                        speedValue={this.speed}\n                    >\n                    </SideOptions>\n                </div>\n\n\n\n                <div className=\"grid\">\n                    {this.state.gridComp.map((row, rowid) =>\n                        // <div id={rowid} className=\"row\"> {row.map((item) => (item.node))} </div>\n                        row.map((item) => (item.node))\n                    )\n                    } </div>\n            </div>\n        )\n    }\n    handleGridItemChange(ref, x, y) {\n        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n            return\n        }\n        let className = ref.current.className\n        switch (className) {\n            case \"node wall\":\n                this.makeNode(x, y)\n                break;\n            default:\n                this.makeWall(x, y)\n                break;\n        }\n\n\n    }\n    isStartOrEnd(x, y) {\n        //console.log(x, y);\n        return this.state.grid[y][x].start || this.state.grid[y][x].end\n    }\n    makeWall(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = true\n        this.accessRef(this.state.grid[y][x]).className = \"node wall\"\n    }\n    makeNode(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = false\n        this.accessRef(this.state.grid[y][x]).className = \"node\"\n    }\n    handleMouseDown(ref, x, y) {\n        if (this.nodeEquals({ x, y }, START_POS)) {\n            console.log(\"start\");\n            this.state.lastPressed = \"start\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        if (this.nodeEquals({ x, y }, END_POS)) {\n            console.log(\"end\");\n            this.state.lastPressed = \"end\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        this.setState({ mouseIsPressed: true })\n\n        this.handleGridItemChange(ref, x, y, true)\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    setStartEnd(x, y) {\n        switch (this.state.lastPressed) {\n            case \"start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = { x, y }\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = { x, y }\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n        switch (this.accessRef(this.state.lastSwitched).className) {\n            case \"node start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = this.state.lastSwitched\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"node end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = this.state.lastSwitched\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n    }\n    handleMouseEnter(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            console.log(x, y);\n            console.log(this.state.lastSwitched);\n            this.accessRef(this.state.lastSwitched).className = this.accessRef({ x, y }).className\n            ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastSwitched = { x, y }\n        }\n        if (!this.state.mouseIsPressed) {\n            return\n        }\n        this.handleGridItemChange(ref, x, y)\n        // ref.current.className.includes(\"wall\") ? ref.current.className = \"node\" : ref.current.className = \"node wall\"\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    handleMouseUp(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            //ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastPressed = null\n            this.state.lastSwitched = null\n        }\n        this.setState({ mouseIsPressed: false })\n        console.log(\"mouse up\");\n\n    }\n    createBlankGrid() {\n        let grid = [];\n        let gridcomp = []\n        for (let y = 0; y < Math.floor(BOARD_HEIGHT); y++) {\n            let row = [];\n            let rowcomp = []\n            for (let x = 0; x < BOARD_WIDTH; x++) {\n                let curref = React.createRef()\n                let type = this.nodeEquals({ x: x, y: y }, START_POS) ? \" start\" : this.nodeEquals({ x: x, y: y }, END_POS) ? \" end\" : \"\"\n                let curnode = (< Node x={x}\n                    y={y}\n                    mouseIsPressed={this.state.mouseIsPressed}\n                    onMouseDown={\n                        (ref) => this.handleMouseDown(ref, x, y)}\n                    onMouseEnter={\n                        (ref) => this.handleMouseEnter(ref, x, y)}\n                    onMouseUp={\n                        (ref) => this.handleMouseUp(ref, x, y)}\n                    refpass={curref}\n                    type={\"node\" + type}\n                >\n                </Node>)\n                let curitem = {\n                    x: x,\n                    y: y,\n                    f: Infinity,\n                    h: 0,\n                    g: 0,\n                    start: type == \" start\",\n                    end: type == \" end\",\n                    wall: false\n                }\n                row.push(curitem)\n                let curcomp = {\n                    x: x,\n                    y: y,\n                    node: curnode,\n                    ref: curref\n                }\n                rowcomp.push(curcomp)\n            }\n            grid.push(row)\n            gridcomp.push(rowcomp)\n        }\n        let test = []\n        test.push(grid)\n        test.push(gridcomp)\n        return test\n    }\n    recursiveDivisionGrid() {\n\n        let width = this.state.grid[0].length\n        let height = this.state.grid.length\n        let cells = []\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (y == 0 || y == height - 1) {\n                    cells.push({ x, y })\n                    //this.makeWall(x, y)\n                }\n            }\n\n            //this.makeWall(0, y)\n            cells.push({ x: 0, y })\n            //this.makeWall(width - 1, y)\n            cells.push({ x: width - 1, y })\n\n        }\n        return cells.concat(this.divide(true, 2, width - 3, 2, height - 3, [], true))\n\n    }\n    divide(h, minX, maxX, minY, maxY, animationCells = [], initial = false) {\n        console.log(initial);\n        console.log(\"haha\");\n        if (initial) {\n            h = true\n        }\n        if (maxY - minY > maxX - minX || (maxY - minY == maxX - minX) && Math.floor(Math.random() * 2) == 1) {\n            // if (h) {\n            if (maxX - minX < 1) {\n                return animationCells\n            }\n\n            var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2\n            if (initial) {\n                console.log(\"apples\");\n                y = minY + Math.floor((maxY - minX) / 2)\n            }\n            animationCells = animationCells.concat(this.addHWall(minX, maxX, y))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, minY, y - 2))\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, y + 2, maxY))\n        } else {\n            if (maxY - minY < 1) {\n                return animationCells\n            }\n\n            var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2\n            animationCells = animationCells.concat(this.addVWall(minY, maxY, x))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, x - 2, minY, maxY))\n            animationCells = animationCells.concat(this.divide(!h, x + 2, maxX, minY, maxY))\n        }\n        return animationCells\n\n    }\n    addHWall(minX, maxX, y) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        var hole2 = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        console.log(minX, maxX, hole);\n        hole2 = 999\n        for (var i = minX - 1; i <= maxX + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(i, y)\n                continue\n            }\n            cells.push({ x: i, y: y })\n        }\n        return cells\n    }\n\n    addVWall(minY, maxY, x) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1\n\n        var hole2 = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\n        console.log(minY, maxY, hole);\n        hole2 = 999\n        for (var i = minY - 1; i <= maxY + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(x, i)\n                continue\n            }\n            cells.push({ x: x, y: i })\n        }\n        return cells\n    }\n\n    randomNumber(min, max) {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}","/mnt/d/code/projects/newpathfinding/src/Pathfinding/Node/Node.js",["82"],"import React, { Component, createRef } from 'react'\nimport './node.scss'\nexport default class Node extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            x: props.x,\n            y: props.y,\n            id: +props.x + \"|\" + props.y,\n            class: props.type,\n            ref: props.refpass,\n        }\n        \n    }\n    render() {\n        return (\n            <div id={this.state.id} className={this.state.class}\n                ref={this.state.ref}\n                onMouseDown={() => this.props.onMouseDown(this.state.ref,this.state.x,this.state.y)}\n                onMouseEnter={() => this.props.onMouseEnter(this.state.ref,this.state.x,this.state.y)}\n                onMouseUp={() => this.props.onMouseUp(this.state.ref,this.state.x,this.state.y)}>\n            </div>\n        )\n    }\n}\n","/mnt/d/code/projects/newpathfinding/src/Pathfinding/pathfinding.js",["83"],"export default class pathfinder {\n    constructor() {\n        this.astar = null\n    }\n    solveAstar(grid, start, end) {\n        this.astar = new astar(start, end, grid)\n        return this.astar.solve()\n    }\n\n\n}\n\nclass astar {\n    constructor(start, end, grid) {\n        this.START_POS = start\n        this.END_POS = end\n        this.grid = grid;\n        console.log(start);\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n    }\n    solve() {\n        let open = []\n        let openAnimationCells = []\n        let closed = []\n        console.log(this.START_POS);\n        let start = this.grid[this.START_POS.y][this.START_POS.x]\n        let end = this.grid[this.END_POS.y][this.END_POS.x]\n        console.log(this.grid);\n        start.f = 0\n        start.g = 0\n        start.start = true\n        end.end = true\n        start.parent = null\n        open.push(start)\n        while (open.length > 0) {\n            open.sort((a, b) => (a.f > b.f) ? 1 : -1)\n\n            if (open.length > 5) {\n                //return\n            }\n            let cur = open[0]\n            open = open.slice(1)\n            let neighbours = this.getNeighbours(cur)\n            for (let i = 0; i < neighbours.length; i++) {\n                let cn = neighbours[i]\n                let clone = JSON.parse(JSON.stringify(cur))\n                cn.parent = clone\n                if (cn.wall) {\n                    continue\n                }\n                // fin conditon\n                if (cn.end) {\n                    console.log(\"finished\");\n                    let cc = cn\n                    let path = []\n                    while (cc != null && !(cc.start)) {\n                        path.push(cc)\n                        cc = cc.parent\n                    }\n                    path.reverse()\n\n                    return [path, openAnimationCells]\n\n\n                }\n                let g = cur.g\n                cn.g = cn.diagonal ? g + 2 : g + 1\n                cn.h = this.heuristic(cn, end)\n                cn.f = cn.g + cn.h\n\n                let obj2 = null\n                let indexclosed = null\n                for (let x = 0; x < closed.length; x++) {\n\n                    if (this.nodeEquals(closed[x], cn)) {\n                        obj2 = closed[x]\n                        indexclosed = x\n                        break\n                    }\n                }\n                if (obj2 != null) {\n                    if (cn.g < obj2.g) {\n                        open.push(cn.g)\n                    }\n                    continue\n                }\n                let obj = null\n                let openindex = null\n                for (let x = 0; x < open.length; x++) {\n\n                    if (this.nodeEquals(open[x], cn)) {\n                        obj = open[x]\n                        openindex = x\n                        break\n                    }\n                }\n                if (obj != null) {\n                    //console.log(\"switched\", this.accessRef(open[openindex]));\n                    if (cn.g < obj.g) {\n                        openAnimationCells.push(cn)\n                        open[openindex] = cn\n                    }\n                    continue\n                }\n                open.push(cn)\n                openAnimationCells.push(cn)\n\n\n\n\n            }\n            closed.push(cur)\n        }\n        return [[], openAnimationCells]\n    }\n    heuristic(pos0, pos1) {\n        var a = pos0.x - pos1.x\n        var b = pos0.y - pos1.y\n\n        return Math.sqrt(a * a + b * b)\n    }\n    getNeighbours(node, diagonal = false) {\n        let grid = this.grid\n        var ret = [];\n        var x = node.y\n        var y = node.x\n\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y]);\n        }\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y]);\n        }\n        if (grid[x][y - 1]) {\n            ret.push(grid[x][y - 1]);\n        }\n        if (grid[x][y + 1]) {\n            ret.push(grid[x][y + 1]);\n        }\n        let ret2 = []\n        if (diagonal) {\n\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret2.push(grid[x + 1][y + 1]);\n            }\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret2.push(grid[x + 1][y - 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret2.push(grid[x - 1][y + 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret2.push(grid[x - 1][y - 1]);\n            }\n            for (let i = 0; i < ret2.length; i++) {\n                ret2[i].diagonal = true;\n            }\n        }\n        // for (let x = 0; x < ret.length; x++) {\n        //     ret[x].parent = null\n        // }\n        return ret.concat(ret2);\n    }\n\n}","/mnt/d/code/projects/newpathfinding/src/main.js",[],"/mnt/d/code/projects/newpathfinding/src/Sorting/Sorting.js",[],"/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Bar.js",["84","85","86","87","88","89","90","91","92","93","94"],"\nimport React, { Component, useRef } from 'react'\nimport './Bar.css'\nimport { mergeSort } from './Algorithms/topdownmergesort'\nimport ReactSlider from 'react-slider'\nimport styled from 'styled-components';\nexport default class Bar extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { arraySize: 11 ,array: [],speed:25}\n    }\n    componentDidMount(){\n        this.setState({array:this.generateRandomArray()})\n    }\n    generateRandomArray(len = this.state.arraySize, min = 1, max = 100) {\n        let array = []\n        for (let x = 0; x < len; x++) {\n            array.push(Math.floor(Math.random() * (max - min + 1)) + min)\n        }\n        console.log(array);\n        return array\n    }\n    shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n    animateMergeSort(anims) {\n        let speed = this.state.speed\n        console.log(speed);\n        anims.forEach((curAnim, index) => {\n            setTimeout(() => {\n                const bars = document.getElementById(\"barContainer\")\n                const info = document.getElementById(\"info\")\n                switch (curAnim.type) {\n\n                    case \"compare\":\n                        {\n        \n                            const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                            const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n        \n                            info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                            info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n        \n        \n                            //console.log(bars);\n                            bars.children[barOneIdx].classList = \"bar compare\"\n                            bars.children[barTwoIdx].classList = \"bar compare\"\n                            bars.children[chosenID].classList = \"bar chosen\"\n                            \n        \n                            break;\n                        }\n                    case \"change\":\n                        const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                        console.log(curAnim.vals);\n                        const barOneStyle = bars.children[barOneIdx].style;\n                        //bars.children[barOneIdx].innerText = newHeight\n                        info.innerText = `setting value`\n                        if (cleanup != undefined) {\n                            info.innerText += `\\none side is empty, adding larger elements at end`\n                        }\n                        barOneStyle.height = `${newHeight}%`;\n                        bars.children[barOneIdx].classList = \"bar sorted\"\n        \n                        break;\n                    case \"split\": {\n                        const [leftStartID, leftEndID] = curAnim.left\n                        const [rightStartID, rightEndID] = curAnim.right\n                        const [middleLeft, middleRight] = curAnim.middle\n                        info.innerText = `splitting`\n                        console.log(curAnim.middle);\n        \n                        console.log(bars.children[middleLeft], bars.children[middleRight]);\n        \n                        for (let x = leftStartID; x <= leftEndID; x++) {\n                            bars.children[x].classList = \"bar left\"\n                        }\n                        for (let x = rightStartID; x <= rightEndID; x++) {\n                            bars.children[x].classList = \"bar right\"\n                        }\n                        bars.children[middleLeft].classList += \" split-left\"\n                        bars.children[middleRight].classList += \" split-right\"\n                    }\n                        break;\n                    case \"merge\": {\n                        //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n        \n                    }\n                }\n                setTimeout(() => {\n                    this.removeLastStep(curAnim)\n                }, speed/2);\n            }, index * speed);\n\n        })\n    }\n    removeLastStep(curAnim = this.lastStep) {\n        const bars = document.getElementById(\"barContainer\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n                    bars.children[barOneIdx].classList = \"bar\"\n                    bars.children[barTwoIdx].classList.value = \"bar\"\n                    bars.children[chosenID].classList = \"bar\"\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight] = curAnim.vals;\n\n                bars.children[barOneIdx].classList = \"bar\"\n                break;\n            case \"split\": {\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                bars.children[middleLeft].classList = \"bar\"\n                bars.children[middleRight].classList = \"bar\"\n\n                for (let x = leftStartID; x < leftEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n\n\n            }\n\n        }\n    }\n    stepAnimateMergeSort() {\n        if (!this.animations || this.animations == null) {\n            this.animations = this.mergeSortArray()\n        }\n        if (this.lastStep) {\n            this.removeLastStep()\n        }\n        let curAnim = this.animations.shift()\n        this.lastStep = curAnim\n        const bars = document.getElementById(\"barContainer\")\n        const info = document.getElementById(\"info\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n\n                    info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                    info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n\n\n                    //console.log(bars);\n                    bars.children[barOneIdx].classList = \"bar compare\"\n                    bars.children[barTwoIdx].classList = \"bar compare\"\n                    bars.children[chosenID].classList = \"bar chosen\"\n\n\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                console.log(curAnim.vals);\n                const barOneStyle = bars.children[barOneIdx].style;\n                //bars.children[barOneIdx].innerText = newHeight\n                info.innerText = `setting value`\n                if (cleanup != undefined) {\n                    info.innerText += `\\none side is empty, adding larger elements at end`\n                }\n                barOneStyle.height = `${newHeight}%`;\n                bars.children[barOneIdx].classList = \"bar sorted\"\n\n                break;\n            case \"split\": {\n                //anims.push({ type: \"split\", left: [startIdx, middleIdx], right: [middleIdx + 1, endIdx] })\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                info.innerText = `splitting`\n                console.log(curAnim.middle);\n\n                console.log(bars.children[middleLeft], bars.children[middleRight]);\n\n                for (let x = leftStartID; x <= leftEndID; x++) {\n                    bars.children[x].classList = \"bar left\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar right\"\n                }\n                bars.children[middleLeft].classList += \" split-left\"\n                bars.children[middleRight].classList += \" split-right\"\n            }\n                break;\n            case \"merge\": {\n                //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n\n            }\n        }\n    }\n    mergeSortArray(animate = false) {\n        const anims = []\n        let arrayCopy = this.state.array.slice()\n        const auxArray = arrayCopy.slice()\n        mergeSort(arrayCopy, 0, arrayCopy.length - 1, auxArray, anims)\n        console.log(anims);\n        console.log(arrayCopy);\n        console.log(auxArray);\n        if (animate) {\n            this.animateMergeSort(anims)\n        }\n        return anims\n\n    }\n    \n    genNewArray(val = 11) {\n        this.setState({ array: this.generateRandomArray(val) },()=>this.setState({arraySize:val}))\n    }\n    createStyledSliders() {\n        const StyledSlider = styled(ReactSlider)`\n        width: 25%;\n        height: 25px;\n    `;\n\n        const StyledThumb = styled.div`\n        height: 25px;\n        line-height: 25px;\n        width: 25px;\n        text-align: center;\n        background-color: #000;\n        color: #fff;\n        border-radius: 50%;\n        cursor: grab;\n    `;\n\n        const Thumb = (props, state) => <StyledThumb {...props}>{props.label}</StyledThumb>;\n\n        const StyledTrack = styled.div`\n        top: 0;\n        bottom: 0;\n        background: ${props => props.index === 2 ? '' : props.index === 1 ? '#0f0' : '#f00'};\n        border-radius: 999px;\n    `;\n        const Track = (props, state) => <StyledTrack {...props} index={state.index} />;\n        return (\n            <div>\n                <StyledSlider\n                 onAfterChange={(val) => this.setState({speed:val})}\n                min={1}\n                max={500}\n                invert={true}\n                defaultValue={this.state.speed}\n                renderTrack={Track}\n                renderThumb={Thumb}\n            />\n            <StyledSlider\n                 onAfterChange={(val)=>this.genNewArray(val)}\n                min={1}\n                max={500}\n                defaultValue={this.state.arraySize}\n                renderTrack={Track}\n                renderThumb={Thumb}\n            />\n            </div>\n        )\n    }\n    render() {\n        return (\n            <div>\n                {this.createStyledSliders()}\n\n                <div className=\"barContainer\" id=\"barContainer\">\n                    {this.state.array.map((curEle) => { return <div ref={curEle.ref} className=\"bar\" style={{ height: `${curEle}%`, width: `${99 / this.state.array.length}vw` , margin:`${(99 / this.state.array.length)/50}vw` }}></div> })}\n                </div>\n                <button onClick={() => this.mergeSortArray(true)}>\n                    sort\n            </button>\n                <button onClick={() => this.genNewArray(this.state.arraySize)}>\n                    random\n            </button>\n                <button onClick={() => this.stepAnimateMergeSort()}>\n                    step\n            </button>\n                <div id=\"info\">\n                    info\n            </div>\n            </div>\n        )\n    }\n}\n","/mnt/d/code/projects/newpathfinding/src/Sorting/Bar/Algorithms/topdownmergesort.js",["95","96","97"],"export function mergeSort(\n    array,\n    start,\n    end,\n    workArray,\n    anims\n) {\n    if (start == end) {\n        return\n    }\n    const initialStart = start\n    const initialEnd = end\n    const middle = Math.floor((start + end) / 2)\n    anims.push({ type: \"split\", left: [start, middle], right: [middle + 1, end], middle: [middle, middle + 1] })//initial split\n    mergeSort(workArray, start, middle, array, anims);\n    mergeSort(workArray, middle + 1, end, array, anims);\n    anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n    merge(array, start, middle, end, workArray, anims);\n}\nfunction merge(\n    array,\n    start,\n    middle,\n    end,\n    workArray,\n    anims\n) {\n\n    let k = start\n    let i = start\n    let j = middle + 1\n    //perform the merge in sort order\n    while (i <= middle && j <= end) {\n        //compare\n        anims.push({ type: \"compare\", vals: [i, j, (workArray[i] <= workArray[j]) ? i : j] })\n        if (workArray[i] <= workArray[j]) {\n            anims.push({ type: \"change\", vals: [k, workArray[i]] });\n            array[k++] = workArray[i++];\n        } else {\n            anims.push({ type: \"change\", vals: [k, workArray[j]] });\n            array[k++] = workArray[j++];\n        }\n    }\n\n\n    //pick up the last element(s)\n    while (i <= middle) {\n        anims.push({ type: \"change\", vals: [k, workArray[i], i] });\n        array[k++] = workArray[i++];\n    }\n    while (j <= end) {\n        anims.push({ type: \"change\", vals: [k, workArray[j], j] });\n        array[k++] = workArray[j++];\n    }\n}","/mnt/d/code/projects/newpathfinding/src/Sidebar/SideOptions.js",["98","99"],"\"use strict\";\n\nimport React, { Component } from \"react\";\nimport { OffCanvas, OffCanvasMenu, OffCanvasBody } from \"react-offcanvas\";\nimport './SideOptions.scss'\nexport default class SideOptions extends Component {\n  constructor(props) {\n    super(props)\n    this.solve = props.solve;\n    this.speedCall = props.speed;\n    this.speed = props.speedValue;\n\n  }\n  speedCallback(sp){\n    this.setState({speed:sp},this.speedCall(sp))\n  }\n  componentWillMount() {\n    // sets the initial state\n    this.setState({\n      isMenuOpened: false,\n      speed:this.speed\n      \n    });\n  }\n\n  render() {\n    let sideArrowClass = `button switch${this.state.isMenuOpened ? \" rightArrow\" : \"\"}`\n    return (\n      <OffCanvas\n        transitionDuration={300}\n        effect={\"push\"}\n        isMenuOpened={this.state.isMenuOpened}\n        position={\"right\"}\n      >\n        <OffCanvasBody\n\n        >\n          <div className=\"open-settings\">\n          \n            <a className={sideArrowClass} onClick={this.handleClick.bind(this)}>\n              <div className=\"arrow\"></div>\n            </a>\n            \n\n          </div>\n        </OffCanvasBody>\n        <OffCanvasMenu\n          className=\"settings\" \n        >\n\n          <div className=\"speed-slider\">\n            <div className=\"speed-label\">\n              Speed {Math.abs(this.state.speed-30)}\n            </div>\n          <input defaultValue={this.state.speed} min={2} max={30} type=\"range\" onChange={(e)=>{this.speedCallback(e.target.value)}}/>\n          </div>\n          <div className=\"side-solve\" onClick={this.solveClose.bind(this)} >\n            Solve\n              </div>\n\n        </OffCanvasMenu>\n      </OffCanvas>\n    );\n  }\n\n  handleClick() {\n    // toggles the menu opened state\n    this.setState({ isMenuOpened: !this.state.isMenuOpened });\n  }\n  solveClose() {\n    this.setState({ isMenuOpened: false }, this.solve);\n  }\n}",{"ruleId":"100","replacedBy":"101"},{"ruleId":"102","replacedBy":"103"},{"ruleId":"104","severity":1,"message":"105","line":108,"column":25,"nodeType":"106","messageId":"107","endLine":108,"endColumn":27},{"ruleId":"108","severity":1,"message":"109","line":160,"column":21,"nodeType":"110","endLine":160,"endColumn":42},{"ruleId":"108","severity":1,"message":"109","line":224,"column":13,"nodeType":"110","endLine":224,"endColumn":54},{"ruleId":"108","severity":1,"message":"109","line":225,"column":13,"nodeType":"110","endLine":225,"endColumn":50},{"ruleId":"108","severity":1,"message":"109","line":313,"column":9,"nodeType":"110","endLine":313,"endColumn":30},{"ruleId":"108","severity":1,"message":"109","line":320,"column":9,"nodeType":"110","endLine":320,"endColumn":30},{"ruleId":"108","severity":1,"message":"109","line":326,"column":13,"nodeType":"110","endLine":326,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":327,"column":13,"nodeType":"110","endLine":327,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":332,"column":13,"nodeType":"110","endLine":332,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":333,"column":13,"nodeType":"110","endLine":333,"endColumn":23},{"ruleId":"111","severity":1,"message":"112","line":342,"column":9,"nodeType":"113","messageId":"114","endLine":354,"endColumn":10},{"ruleId":"108","severity":1,"message":"109","line":344,"column":17,"nodeType":"110","endLine":344,"endColumn":58},{"ruleId":"108","severity":1,"message":"109","line":346,"column":17,"nodeType":"110","endLine":346,"endColumn":58},{"ruleId":"108","severity":1,"message":"109","line":350,"column":17,"nodeType":"110","endLine":350,"endColumn":54},{"ruleId":"108","severity":1,"message":"109","line":352,"column":17,"nodeType":"110","endLine":352,"endColumn":54},{"ruleId":"111","severity":1,"message":"112","line":355,"column":9,"nodeType":"113","messageId":"114","endLine":367,"endColumn":10},{"ruleId":"108","severity":1,"message":"109","line":357,"column":17,"nodeType":"110","endLine":357,"endColumn":58},{"ruleId":"108","severity":1,"message":"109","line":359,"column":17,"nodeType":"110","endLine":359,"endColumn":58},{"ruleId":"108","severity":1,"message":"109","line":363,"column":17,"nodeType":"110","endLine":363,"endColumn":54},{"ruleId":"108","severity":1,"message":"109","line":365,"column":17,"nodeType":"110","endLine":365,"endColumn":54},{"ruleId":"108","severity":1,"message":"109","line":377,"column":13,"nodeType":"110","endLine":377,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":391,"column":13,"nodeType":"110","endLine":391,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":392,"column":13,"nodeType":"110","endLine":392,"endColumn":23},{"ruleId":"104","severity":1,"message":"105","line":426,"column":33,"nodeType":"106","messageId":"107","endLine":426,"endColumn":35},{"ruleId":"104","severity":1,"message":"105","line":427,"column":31,"nodeType":"106","messageId":"107","endLine":427,"endColumn":33},{"ruleId":"104","severity":1,"message":"105","line":454,"column":23,"nodeType":"106","messageId":"107","endLine":454,"endColumn":25},{"ruleId":"104","severity":1,"message":"105","line":454,"column":33,"nodeType":"106","messageId":"107","endLine":454,"endColumn":35},{"ruleId":"115","severity":1,"message":"116","line":475,"column":39,"nodeType":"117","messageId":"118","endLine":475,"endColumn":41},{"ruleId":"104","severity":1,"message":"105","line":475,"column":55,"nodeType":"106","messageId":"107","endLine":475,"endColumn":57},{"ruleId":"115","severity":1,"message":"116","line":475,"column":71,"nodeType":"117","messageId":"118","endLine":475,"endColumn":73},{"ruleId":"104","severity":1,"message":"105","line":475,"column":104,"nodeType":"106","messageId":"107","endLine":475,"endColumn":106},{"ruleId":"119","severity":1,"message":"120","line":1,"column":28,"nodeType":"121","messageId":"122","endLine":1,"endColumn":37},{"ruleId":"119","severity":1,"message":"123","line":81,"column":25,"nodeType":"121","messageId":"122","endLine":81,"endColumn":36},{"ruleId":"119","severity":1,"message":"124","line":2,"column":28,"nodeType":"121","messageId":"122","endLine":2,"endColumn":34},{"ruleId":"111","severity":1,"message":"112","line":37,"column":17,"nodeType":"113","messageId":"114","endLine":93,"endColumn":18},{"ruleId":"104","severity":1,"message":"105","line":43,"column":54,"nodeType":"106","messageId":"107","endLine":43,"endColumn":56},{"ruleId":"104","severity":1,"message":"125","line":63,"column":37,"nodeType":"106","messageId":"107","endLine":63,"endColumn":39},{"ruleId":"111","severity":1,"message":"112","line":103,"column":9,"nodeType":"113","messageId":"114","endLine":137,"endColumn":10},{"ruleId":"119","severity":1,"message":"126","line":109,"column":27,"nodeType":"121","messageId":"122","endLine":109,"endColumn":33},{"ruleId":"104","severity":1,"message":"105","line":109,"column":46,"nodeType":"106","messageId":"107","endLine":109,"endColumn":48},{"ruleId":"119","severity":1,"message":"127","line":116,"column":35,"nodeType":"121","messageId":"122","endLine":116,"endColumn":44},{"ruleId":"111","severity":1,"message":"112","line":150,"column":9,"nodeType":"113","messageId":"114","endLine":207,"endColumn":10},{"ruleId":"104","severity":1,"message":"105","line":156,"column":46,"nodeType":"106","messageId":"107","endLine":156,"endColumn":48},{"ruleId":"104","severity":1,"message":"125","line":176,"column":29,"nodeType":"106","messageId":"107","endLine":176,"endColumn":31},{"ruleId":"104","severity":1,"message":"105","line":8,"column":15,"nodeType":"106","messageId":"107","endLine":8,"endColumn":17},{"ruleId":"104","severity":1,"message":"105","line":17,"column":78,"nodeType":"106","messageId":"107","endLine":17,"endColumn":80},{"ruleId":"104","severity":1,"message":"105","line":17,"column":101,"nodeType":"106","messageId":"107","endLine":17,"endColumn":103},{"ruleId":"128","severity":1,"message":"129","line":1,"column":1,"nodeType":"130","messageId":"131","endLine":1,"endColumn":14,"fix":"132"},{"ruleId":"133","severity":1,"message":"134","line":40,"column":13,"nodeType":"135","endLine":40,"endColumn":81},"no-native-reassign",["136"],"no-negated-in-lhs",["137"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","no-unused-vars","'createRef' is defined but never used.","Identifier","unusedVar","'indexclosed' is assigned a value but never used.","'useRef' is defined but never used.","Expected '!==' and instead saw '!='.","'higher' is assigned a value but never used.","'newHeight' is assigned a value but never used.","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"138","text":"139"},"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-global-assign","no-unsafe-negation",[0,13],""]