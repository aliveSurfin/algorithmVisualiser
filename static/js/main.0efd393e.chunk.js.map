{"version":3,"sources":["Pathfinding/pathfinding.js","Pathfinding/Node/Node.js","Pathfinding/Board/Board.js","Sorting/Bar/Algorithms/topdownmergesort.js","Sorting/Bar/Bar.js","Sorting/Sorting.js","main.js","App.js","reportWebVitals.js","index.js"],"names":["pathfinder","this","astar","grid","start","end","solve","START_POS","END_POS","console","log","n1","n2","x","y","open","openAnimationCells","closed","f","g","parent","push","length","sort","a","b","cur","slice","neighbours","getNeighbours","i","cn","clone","JSON","parse","stringify","wall","cc","path","reverse","diagonal","h","heuristic","obj2","nodeEquals","obj","openindex","pos0","pos1","Math","sqrt","node","ret","ret2","concat","Node","props","state","id","class","type","ref","refpass","className","onMouseDown","onMouseEnter","onMouseUp","Component","floor","BOARD_HEIGHT","BOARD_WIDTH","Board","gridComp","mouseIsPressed","lastPressed","lastSwitched","ele","current","resettimeout","resetGrid","recursiveDivisionGrid","setTimeout","passage","accessRef","extra","horizontal","makeWall","speed","removePathOpenCurrent","test","solveAstar","animateastar","replace","wipe","window","clearTimeout","firstNonNode","lastNonNode","includes","reset","resetStartEnd","grids","createBlankGrid","setState","onClick","createRecursiveMaze","aStarSolve","map","row","rowid","item","makeNode","isStartOrEnd","handleGridItemChange","setStartEnd","gridcomp","rowcomp","curref","React","createRef","curnode","handleMouseDown","handleMouseEnter","handleMouseUp","curitem","Infinity","curcomp","width","height","cells","divide","minX","maxX","minY","maxY","animationCells","randomNumber","addHWall","addVWall","hole","min","max","random","mergeSort","array","workArray","anims","initialStart","initialEnd","middle","left","right","last","k","j","vals","merge","Bar","arraySize","generateRandomArray","len","forEach","curAnim","index","bars","document","getElementById","info","barOneIdx","barTwoIdx","chosenID","higher","innerText","children","style","split","classList","newHeight","cleanup","barOneStyle","undefined","leftStartID","leftEndID","rightStartID","rightEndID","middleLeft","middleRight","removeLastStep","lastStep","value","animations","mergeSortArray","shift","animate","arrayCopy","auxArray","animateMergeSort","val","StyledSlider","styled","ReactSlider","StyledThumb","div","Thumb","label","StyledTrack","Track","onAfterChange","invert","defaultValue","renderTrack","renderThumb","genNewArray","createStyledSliders","curEle","margin","stepAnimateMergeSort","Sorting","Main","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0efd393e.chunk.js","sourcesContent":["export default class pathfinder {\n    constructor() {\n        this.astar = null\n    }\n    solveAstar(grid, start, end) {\n        this.astar = new astar(start, end, grid)\n        return this.astar.solve()\n    }\n\n\n}\n\nclass astar {\n    constructor(start, end, grid) {\n        this.START_POS = start\n        this.END_POS = end\n        this.grid = grid;\n        console.log(start);\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n    }\n    solve() {\n        let open = []\n        let openAnimationCells = []\n        let closed = []\n        console.log(this.START_POS);\n        let start = this.grid[this.START_POS.y][this.START_POS.x]\n        let end = this.grid[this.END_POS.y][this.END_POS.x]\n        console.log(this.grid);\n        start.f = 0\n        start.g = 0\n        start.start = true\n        end.end = true\n        start.parent = null\n        open.push(start)\n        while (open.length > 0) {\n            open.sort((a, b) => (a.f > b.f) ? 1 : -1)\n\n            if (open.length > 5) {\n                //return\n            }\n            let cur = open[0]\n            open = open.slice(1)\n            let neighbours = this.getNeighbours(cur)\n            for (let i = 0; i < neighbours.length; i++) {\n                let cn = neighbours[i]\n                let clone = JSON.parse(JSON.stringify(cur))\n                cn.parent = clone\n                if (cn.wall) {\n                    continue\n                }\n                // fin conditon\n                if (cn.end) {\n                    console.log(\"finished\");\n                    let cc = cn\n                    let path = []\n                    while (cc != null && !(cc.start)) {\n                        path.push(cc)\n                        cc = cc.parent\n                    }\n                    path.reverse()\n\n                    return [path, openAnimationCells]\n\n\n                }\n                let g = cur.g\n                cn.g = cn.diagonal ? g + 2 : g + 1\n                cn.h = this.heuristic(cn, end)\n                cn.f = cn.g + cn.h\n\n                let obj2 = null\n                let indexclosed = null\n                for (let x = 0; x < closed.length; x++) {\n\n                    if (this.nodeEquals(closed[x], cn)) {\n                        obj2 = closed[x]\n                        indexclosed = x\n                        break\n                    }\n                }\n                if (obj2 != null) {\n                    if (cn.g < obj2.g) {\n                        open.push(cn.g)\n                    }\n                    continue\n                }\n                let obj = null\n                let openindex = null\n                for (let x = 0; x < open.length; x++) {\n\n                    if (this.nodeEquals(open[x], cn)) {\n                        obj = open[x]\n                        openindex = x\n                        break\n                    }\n                }\n                if (obj != null) {\n                    //console.log(\"switched\", this.accessRef(open[openindex]));\n                    if (cn.g < obj.g) {\n                        openAnimationCells.push(cn)\n                        open[openindex] = cn\n                    }\n                    continue\n                }\n                open.push(cn)\n                openAnimationCells.push(cn)\n\n\n\n\n            }\n            closed.push(cur)\n        }\n        return [[], openAnimationCells]\n    }\n    heuristic(pos0, pos1) {\n        var a = pos0.x - pos1.x\n        var b = pos0.y - pos1.y\n\n        return Math.sqrt(a * a + b * b)\n    }\n    getNeighbours(node, diagonal = false) {\n        let grid = this.grid\n        var ret = [];\n        var x = node.y\n        var y = node.x\n\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y]);\n        }\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y]);\n        }\n        if (grid[x][y - 1]) {\n            ret.push(grid[x][y - 1]);\n        }\n        if (grid[x][y + 1]) {\n            ret.push(grid[x][y + 1]);\n        }\n        let ret2 = []\n        if (diagonal) {\n\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret2.push(grid[x + 1][y + 1]);\n            }\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret2.push(grid[x + 1][y - 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret2.push(grid[x - 1][y + 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret2.push(grid[x - 1][y - 1]);\n            }\n            for (let i = 0; i < ret2.length; i++) {\n                ret2[i].diagonal = true;\n            }\n        }\n        // for (let x = 0; x < ret.length; x++) {\n        //     ret[x].parent = null\n        // }\n        return ret.concat(ret2);\n    }\n\n}","import React, { Component, createRef } from 'react'\nimport './node.css'\nexport default class Node extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            x: props.x,\n            y: props.y,\n            id: +props.x + \"|\" + props.y,\n            class: props.type,\n            ref: props.refpass,\n        }\n        \n    }\n    render() {\n        return (\n            <div id={this.state.id} className={this.state.class}\n                ref={this.state.ref}\n                onMouseDown={() => this.props.onMouseDown(this.state.ref,this.state.x,this.state.y)}\n                onMouseEnter={() => this.props.onMouseEnter(this.state.ref,this.state.x,this.state.y)}\n                onMouseUp={() => this.props.onMouseUp(this.state.ref,this.state.x,this.state.y)}>\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport pathfinder from '../pathfinding.js';\nimport Node from '../Node/Node';\n\nimport './board.css'\nvar BOARD_WIDTH = 41\nvar BOARD_HEIGHT = 11\nvar START_POS = { x: 2, y: Math.floor(BOARD_HEIGHT / 2) }\nvar END_POS = { x: BOARD_WIDTH - 3, y: Math.floor(BOARD_HEIGHT / 2) }\n\nexport default class Board extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            gridComp: [],\n            mouseIsPressed: false,\n            lastPressed: null,\n            lastSwitched: null,\n\n        }\n        this.pathfinder = new pathfinder()\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n        return false\n    }\n    accessRef(ele) {\n        return this.state.gridComp[ele.y][ele.x].ref.current\n    }\n    createRecursiveMaze() {\n        let resettimeout = this.resetGrid()\n        let grid = this.recursiveDivisionGrid()\n        console.log(grid);\n        setTimeout(() => {\n\n\n            for (let x = 0; x < grid.length; x++) {\n                setTimeout(() => {\n                    if (this.state.grid[grid[x].y][grid[x].x].passage) {\n                        console.log(\"p\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        if (this.state.grid[grid[x].y][grid[x].x].extra) {\n                            console.log(\"e\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        }\n                        console.log(this.state.grid[grid[x].y][grid[x].x].horizontal);\n                    } else {\n\n                    }\n                    this.makeWall(grid[x].x, grid[x].y)\n\n\n                }, x * 5);\n            }\n        }, resettimeout);\n    }\n    animateRecursiveGrid(speed = 5) {\n        let grid = this.recursiveDivisionGrid()\n        for (let x = 0; x < grid.length; x++) {\n            setTimeout(() => {\n                this.makeWall(grid[x].x, grid[x].y)\n            }, x * (speed * 5));\n        }\n    }\n    aStarSolve() {\n        this.removePathOpenCurrent()\n        let test = this.pathfinder.solveAstar(this.state.grid, START_POS, END_POS)\n\n        this.animateastar(test[0], test[1], 5)\n\n    }\n    animateastar(path, open, speed = 1) {\n        for (let x = 0; x < open.length; x++) {\n            setTimeout(() => {\n                this.accessRef(open[x]).className += \" current\"\n                setTimeout(() => {\n\n                    if (open[x - 1]) {\n                        this.accessRef(open[x - 1]).className = this.accessRef(open[x - 1]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x - 1]).className += \" open\"\n                    }\n                    if (x === open.length - 1) {\n                        this.accessRef(open[x]).className = this.accessRef(open[x]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x]).className += \" open\"\n                    }\n                }, 0);\n\n\n\n            }, x * (speed * 5));\n        }\n        if (path.length == 0) {\n            setTimeout(() => {\n                for (let x = 0; x < open.length; x++) {\n                    this.accessRef(open[x]).className += \" noPath\"\n                }\n\n            }, open.length * (speed) + 100);\n        }\n        setTimeout(() => {\n            for (let x = 0; x < path.length; x++) {\n                setTimeout(() => {\n                    console.log(\"test\");\n                    if (!path[x].start && !path[x].end) {\n                        this.accessRef(path[x]).className = \"node path\"\n                    }\n                }, x * (speed * 7.5));\n\n            }\n        }, (open.length * (speed * 5)) + 100);\n\n\n\n\n\n\n    }\n    resetGrid(wipe = false) {\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let firstNonNode = null\n        let lastNonNode = null\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (firstNonNode == null || x < firstNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        firstNonNode = x\n                    }\n                }\n                if (lastNonNode == null || x > lastNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        lastNonNode = x\n                    }\n                }\n                if (this.state.grid[y][x].wall) {\n                    this.state.grid[y][x].wall = false\n                }\n                if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                    continue\n                }\n                if (!wipe) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n\n            }\n        }\n        if (firstNonNode == null) {\n            firstNonNode = 0\n        }\n        if (lastNonNode == null) {\n            lastNonNode = this.state.grid[0].length - 1\n        }\n        if (wipe) {\n            for (let x = firstNonNode; x <= lastNonNode; x++) {\n\n                // console.log(x);\n                setTimeout(() => {\n                    for (let y = 0; y < this.state.grid.length; y++) {\n                        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                            this.accessRef(this.state.grid[y][x]).className += \" wipe\"\n\n                        } else {\n                            this.accessRef(this.state.grid[y][x]).className = \"node wipe\"\n                        }\n                        setTimeout(() => {\n                            this.accessRef(this.state.grid[y][x]).className = this.accessRef(this.state.grid[y][x]).className.replace(\" wipe\", \"\")\n                        }, 300);\n                    }\n                }, 45 * x);\n            }\n\n            return (45 * this.state.grid[0].length) + 300\n        }\n        return 0\n\n    }\n    removePathOpenCurrent() {\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (this.accessRef(this.state.grid[y][x]).className.includes(\"path\") || this.accessRef(this.state.grid[y][x]).className.includes(\"open\") || this.accessRef(this.state.grid[y][x]).className.includes(\"current\")) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n            }\n        }\n    }\n    resetStartEnd(reset) {\n\n        // START_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // START_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n\n        // END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // while (END_POS.x == START_POS.x && START_POS.y == END_POS.y) {\n        //     END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        //     END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // }\n        if (reset) {\n            this.state.grid[START_POS.y][START_POS.x].start = true\n            this.state.grid[END_POS.y][END_POS.x].end = true\n            this.accessRef(START_POS).className = \"node start\"\n            this.accessRef(END_POS).className = \"node end\"\n        }\n        console.log(START_POS);\n        console.log(END_POS);\n    }\n    componentDidMount() {\n        console.log(new pathfinder().astar);\n        this.resetStartEnd()\n        let grids = this.createBlankGrid()\n        console.log(grids[0]);\n        this.setState({ grid: grids[0], gridComp: grids[1] })\n    }\n    render() {\n        return (\n            <div className=\"container\">\n                <button onClick={() => this.createRecursiveMaze()}>grid</button>\n                <button onClick={() => this.aStarSolve()}>solve</button>\n                <button onClick={() => this.resetGrid(true)}>reset</button>\n                <div className=\"grid\">\n                    {this.state.gridComp.map((row, rowid) =>\n                        <div id={rowid} className=\"row\"> {row.map((item) => (item.node))} </div>\n                    )\n                    } </div>\n            </div>\n        )\n    }\n    handleGridItemChange(ref, x, y) {\n        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n            return\n        }\n        let className = ref.current.className\n        switch (className) {\n            case \"node wall\":\n                this.makeNode(x, y)\n                break;\n            default:\n                this.makeWall(x, y)\n                break;\n        }\n\n\n    }\n    isStartOrEnd(x, y) {\n        //console.log(x, y);\n        return this.state.grid[y][x].start || this.state.grid[y][x].end\n    }\n    makeWall(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = true\n        this.accessRef(this.state.grid[y][x]).className = \"node wall\"\n    }\n    makeNode(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = false\n        this.accessRef(this.state.grid[y][x]).className = \"node\"\n    }\n    handleMouseDown(ref, x, y) {\n        if (this.nodeEquals({ x, y }, START_POS)) {\n            console.log(\"start\");\n            this.state.lastPressed = \"start\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        if (this.nodeEquals({ x, y }, END_POS)) {\n            console.log(\"end\");\n            this.state.lastPressed = \"end\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        this.setState({ mouseIsPressed: true })\n\n        this.handleGridItemChange(ref, x, y, true)\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    setStartEnd(x, y) {\n        switch (this.state.lastPressed) {\n            case \"start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = { x, y }\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = { x, y }\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n        switch (this.accessRef(this.state.lastSwitched).className) {\n            case \"node start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = this.state.lastSwitched\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"node end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = this.state.lastSwitched\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n    }\n    handleMouseEnter(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            console.log(x, y);\n            console.log(this.state.lastSwitched);\n            this.accessRef(this.state.lastSwitched).className = this.accessRef({ x, y }).className\n            ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastSwitched = { x, y }\n        }\n        if (!this.state.mouseIsPressed) {\n            return\n        }\n        this.handleGridItemChange(ref, x, y)\n        // ref.current.className.includes(\"wall\") ? ref.current.className = \"node\" : ref.current.className = \"node wall\"\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    handleMouseUp(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            //ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastPressed = null\n            this.state.lastSwitched = null\n        }\n        this.setState({ mouseIsPressed: false })\n        console.log(\"mouse up\");\n\n    }\n    createBlankGrid() {\n        let grid = [];\n        let gridcomp = []\n        for (let y = 0; y < Math.floor(BOARD_HEIGHT); y++) {\n            let row = [];\n            let rowcomp = []\n            for (let x = 0; x < BOARD_WIDTH; x++) {\n                let curref = React.createRef()\n                let type = this.nodeEquals({ x: x, y: y }, START_POS) ? \" start\" : this.nodeEquals({ x: x, y: y }, END_POS) ? \" end\" : \"\"\n                let curnode = (< Node x={x}\n                    y={y}\n                    mouseIsPressed={this.state.mouseIsPressed}\n                    onMouseDown={\n                        (ref) => this.handleMouseDown(ref, x, y)}\n                    onMouseEnter={\n                        (ref) => this.handleMouseEnter(ref, x, y)}\n                    onMouseUp={\n                        (ref) => this.handleMouseUp(ref, x, y)}\n                    refpass={curref}\n                    type={\"node\" + type}\n                >\n                </Node>)\n                let curitem = {\n                    x: x,\n                    y: y,\n                    f: Infinity,\n                    h: 0,\n                    g: 0,\n                    start: type == \" start\",\n                    end: type == \" end\",\n                    wall: false\n                }\n                row.push(curitem)\n                let curcomp = {\n                    x: x,\n                    y: y,\n                    node: curnode,\n                    ref: curref\n                }\n                rowcomp.push(curcomp)\n            }\n            grid.push(row)\n            gridcomp.push(rowcomp)\n        }\n        let test = []\n        test.push(grid)\n        test.push(gridcomp)\n        return test\n    }\n    recursiveDivisionGrid() {\n\n        let width = this.state.grid[0].length\n        let height = this.state.grid.length\n        let cells = []\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (y == 0 || y == height - 1) {\n                    cells.push({ x, y })\n                    //this.makeWall(x, y)\n                }\n            }\n\n            //this.makeWall(0, y)\n            cells.push({ x: 0, y })\n            //this.makeWall(width - 1, y)\n            cells.push({ x: width - 1, y })\n\n        }\n        return cells.concat(this.divide(false, 2, width - 3, 2, height - 3))\n\n    }\n    divide(h, minX, maxX, minY, maxY, animationCells = []) {\n        //if (maxY - minY > maxX - minX || (maxY - minY == maxX - minX) && Math.floor(Math.random() * 2) == 1) {\n        if (h) {\n            if (maxX - minX < 1) {\n                return animationCells\n            }\n\n            var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2\n            animationCells = animationCells.concat(this.addHWall(minX, maxX, y))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, minY, y - 2))\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, y + 2, maxY))\n        } else {\n            if (maxY - minY < 1) {\n                return animationCells\n            }\n\n            var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2\n            animationCells = animationCells.concat(this.addVWall(minY, maxY, x))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, x - 2, minY, maxY))\n            animationCells = animationCells.concat(this.divide(!h, x + 2, maxX, minY, maxY))\n        }\n        return animationCells\n\n    }\n    addHWall(minX, maxX, y) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        var hole2 = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        console.log(minX, maxX, hole);\n        hole2 = 999\n        for (var i = minX - 1; i <= maxX + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(i, y)\n                continue\n            }\n            cells.push({ x: i, y: y })\n        }\n        return cells\n    }\n\n    addVWall(minY, maxY, x) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1\n\n        var hole2 = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\n        console.log(minY, maxY, hole);\n        hole2 = 999\n        for (var i = minY - 1; i <= maxY + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(x, i)\n                continue\n            }\n            cells.push({ x: x, y: i })\n        }\n        return cells\n    }\n\n    randomNumber(min, max) {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}","export function mergeSort(\n    array,\n    start,\n    end,\n    workArray,\n    anims\n) {\n    if (start == end) {\n        return\n    }\n    const initialStart = start\n    const initialEnd = end\n    const middle = Math.floor((start + end) / 2)\n    anims.push({ type: \"split\", left: [start, middle], right: [middle + 1, end], middle: [middle, middle + 1] })//initial split\n    mergeSort(workArray, start, middle, array, anims);\n    mergeSort(workArray, middle + 1, end, array, anims);\n    anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n    merge(array, start, middle, end, workArray, anims);\n}\nfunction merge(\n    array,\n    start,\n    middle,\n    end,\n    workArray,\n    anims\n) {\n\n    let k = start\n    let i = start\n    let j = middle + 1\n    //perform the merge in sort order\n    while (i <= middle && j <= end) {\n        //compare\n        anims.push({ type: \"compare\", vals: [i, j, (workArray[i] <= workArray[j]) ? i : j] })\n        if (workArray[i] <= workArray[j]) {\n            anims.push({ type: \"change\", vals: [k, workArray[i]] });\n            array[k++] = workArray[i++];\n        } else {\n            anims.push({ type: \"change\", vals: [k, workArray[j]] });\n            array[k++] = workArray[j++];\n        }\n    }\n\n\n    //pick up the last element(s)\n    while (i <= middle) {\n        anims.push({ type: \"change\", vals: [k, workArray[i], i] });\n        array[k++] = workArray[i++];\n    }\n    while (j <= end) {\n        anims.push({ type: \"change\", vals: [k, workArray[j], j] });\n        array[k++] = workArray[j++];\n    }\n}","\nimport React, { Component, useRef } from 'react'\nimport './Bar.css'\nimport { mergeSort } from './Algorithms/topdownmergesort'\nimport ReactSlider from 'react-slider'\nimport styled from 'styled-components';\nexport default class Bar extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { arraySize: 11 ,array: [],speed:25}\n    }\n    componentDidMount(){\n        this.setState({array:this.generateRandomArray()})\n    }\n    generateRandomArray(len = this.state.arraySize, min = 1, max = 100) {\n        let array = []\n        for (let x = 0; x < len; x++) {\n            array.push(Math.floor(Math.random() * (max - min + 1)) + min)\n        }\n        console.log(array);\n        return array\n    }\n    shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n    animateMergeSort(anims) {\n        let speed = this.state.speed\n        console.log(speed);\n        anims.forEach((curAnim, index) => {\n            setTimeout(() => {\n                const bars = document.getElementById(\"barContainer\")\n                const info = document.getElementById(\"info\")\n                switch (curAnim.type) {\n\n                    case \"compare\":\n                        {\n        \n                            const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                            const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n        \n                            info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                            info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n        \n        \n                            //console.log(bars);\n                            bars.children[barOneIdx].classList = \"bar compare\"\n                            bars.children[barTwoIdx].classList = \"bar compare\"\n                            bars.children[chosenID].classList = \"bar chosen\"\n                            \n        \n                            break;\n                        }\n                    case \"change\":\n                        const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                        console.log(curAnim.vals);\n                        const barOneStyle = bars.children[barOneIdx].style;\n                        //bars.children[barOneIdx].innerText = newHeight\n                        info.innerText = `setting value`\n                        if (cleanup != undefined) {\n                            info.innerText += `\\none side is empty, adding larger elements at end`\n                        }\n                        barOneStyle.height = `${newHeight}%`;\n                        bars.children[barOneIdx].classList = \"bar sorted\"\n        \n                        break;\n                    case \"split\": {\n                        const [leftStartID, leftEndID] = curAnim.left\n                        const [rightStartID, rightEndID] = curAnim.right\n                        const [middleLeft, middleRight] = curAnim.middle\n                        info.innerText = `splitting`\n                        console.log(curAnim.middle);\n        \n                        console.log(bars.children[middleLeft], bars.children[middleRight]);\n        \n                        for (let x = leftStartID; x <= leftEndID; x++) {\n                            bars.children[x].classList = \"bar left\"\n                        }\n                        for (let x = rightStartID; x <= rightEndID; x++) {\n                            bars.children[x].classList = \"bar right\"\n                        }\n                        bars.children[middleLeft].classList += \" split-left\"\n                        bars.children[middleRight].classList += \" split-right\"\n                    }\n                        break;\n                    case \"merge\": {\n                        //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n        \n                    }\n                }\n                setTimeout(() => {\n                    this.removeLastStep(curAnim)\n                }, speed/2);\n            }, index * speed);\n\n        })\n    }\n    removeLastStep(curAnim = this.lastStep) {\n        const bars = document.getElementById(\"barContainer\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n                    bars.children[barOneIdx].classList = \"bar\"\n                    bars.children[barTwoIdx].classList.value = \"bar\"\n                    bars.children[chosenID].classList = \"bar\"\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight] = curAnim.vals;\n\n                bars.children[barOneIdx].classList = \"bar\"\n                break;\n            case \"split\": {\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                bars.children[middleLeft].classList = \"bar\"\n                bars.children[middleRight].classList = \"bar\"\n\n                for (let x = leftStartID; x < leftEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n\n\n            }\n\n        }\n    }\n    stepAnimateMergeSort() {\n        if (!this.animations || this.animations == null) {\n            this.animations = this.mergeSortArray()\n        }\n        if (this.lastStep) {\n            this.removeLastStep()\n        }\n        let curAnim = this.animations.shift()\n        this.lastStep = curAnim\n        const bars = document.getElementById(\"barContainer\")\n        const info = document.getElementById(\"info\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n\n                    info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                    info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n\n\n                    //console.log(bars);\n                    bars.children[barOneIdx].classList = \"bar compare\"\n                    bars.children[barTwoIdx].classList = \"bar compare\"\n                    bars.children[chosenID].classList = \"bar chosen\"\n\n\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                console.log(curAnim.vals);\n                const barOneStyle = bars.children[barOneIdx].style;\n                //bars.children[barOneIdx].innerText = newHeight\n                info.innerText = `setting value`\n                if (cleanup != undefined) {\n                    info.innerText += `\\none side is empty, adding larger elements at end`\n                }\n                barOneStyle.height = `${newHeight}%`;\n                bars.children[barOneIdx].classList = \"bar sorted\"\n\n                break;\n            case \"split\": {\n                //anims.push({ type: \"split\", left: [startIdx, middleIdx], right: [middleIdx + 1, endIdx] })\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                info.innerText = `splitting`\n                console.log(curAnim.middle);\n\n                console.log(bars.children[middleLeft], bars.children[middleRight]);\n\n                for (let x = leftStartID; x <= leftEndID; x++) {\n                    bars.children[x].classList = \"bar left\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar right\"\n                }\n                bars.children[middleLeft].classList += \" split-left\"\n                bars.children[middleRight].classList += \" split-right\"\n            }\n                break;\n            case \"merge\": {\n                //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n\n            }\n        }\n    }\n    mergeSortArray(animate = false) {\n        const anims = []\n        let arrayCopy = this.state.array.slice()\n        const auxArray = arrayCopy.slice()\n        mergeSort(arrayCopy, 0, arrayCopy.length - 1, auxArray, anims)\n        console.log(anims);\n        console.log(arrayCopy);\n        console.log(auxArray);\n        if (animate) {\n            this.animateMergeSort(anims)\n        }\n        return anims\n\n    }\n    \n    genNewArray(val = 11) {\n        this.setState({ array: this.generateRandomArray(val) },()=>this.setState({arraySize:val}))\n    }\n    createStyledSliders() {\n        const StyledSlider = styled(ReactSlider)`\n        width: 25%;\n        height: 25px;\n    `;\n\n        const StyledThumb = styled.div`\n        height: 25px;\n        line-height: 25px;\n        width: 25px;\n        text-align: center;\n        background-color: #000;\n        color: #fff;\n        border-radius: 50%;\n        cursor: grab;\n    `;\n\n        const Thumb = (props, state) => <StyledThumb {...props}>{props.label}</StyledThumb>;\n\n        const StyledTrack = styled.div`\n        top: 0;\n        bottom: 0;\n        background: ${props => props.index === 2 ? '' : props.index === 1 ? '#0f0' : '#f00'};\n        border-radius: 999px;\n    `;\n        const Track = (props, state) => <StyledTrack {...props} index={state.index} />;\n        return (\n            <div>\n                <StyledSlider\n                 onAfterChange={(val) => this.setState({speed:val})}\n                min={1}\n                max={500}\n                invert={true}\n                defaultValue={this.state.speed}\n                renderTrack={Track}\n                renderThumb={Thumb}\n            />\n            <StyledSlider\n                 onAfterChange={(val)=>this.genNewArray(val)}\n                min={1}\n                max={500}\n                defaultValue={this.state.arraySize}\n                renderTrack={Track}\n                renderThumb={Thumb}\n            />\n            </div>\n        )\n    }\n    render() {\n        return (\n            <div>\n                {this.createStyledSliders()}\n\n                <div className=\"barContainer\" id=\"barContainer\">\n                    {this.state.array.map((curEle) => { return <div ref={curEle.ref} className=\"bar\" style={{ height: `${curEle}%`, width: `${99 / this.state.array.length}vw` , margin:`${(99 / this.state.array.length)/50}vw` }}></div> })}\n                </div>\n                <button onClick={() => this.mergeSortArray(true)}>\n                    sort\n            </button>\n                <button onClick={() => this.genNewArray(this.state.arraySize)}>\n                    random\n            </button>\n                <button onClick={() => this.stepAnimateMergeSort()}>\n                    step\n            </button>\n                <div id=\"info\">\n                    info\n            </div>\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport Bar from './Bar/Bar'\n\nexport default class Sorting extends Component {\n    render() {\n        return (\n            <Bar></Bar>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport Board from './Pathfinding/Board/Board'\nimport { Tab, TabPanel, Tabs, TabList } from 'react-tabs';\nimport 'react-tabs/style/react-tabs.css';\nimport Sorting from './Sorting/Sorting';\nexport default class Main extends Component {\n    render() {\n        return (\n            <Tabs>\n            <TabList>\n                <Tab>Pathfinding </Tab>\n                <Tab>Sorting </Tab>\n            </TabList>\n            <TabPanel>\n            <Board></Board>\n            </TabPanel>\n            <TabPanel>\n                <Sorting></Sorting>\n            </TabPanel>\n        </Tabs>\n\n        )\n    }\n}\n","import './App.css';\nimport Main from './main'\nfunction App() {\n  return (\n    <Main>\n\n    </Main>\n    )\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}