{"version":3,"sources":["reportWebVitals.js","Pathfinding/pathfinding.js","Pathfinding/Node/Node.js","Sidebar/SideOptions.js","Pathfinding/Board/Board.js","Sorting/Bar/Algorithms/topdownmergesort.js","Sorting/Bar/Bar.js","Sorting/Sorting.js","main.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","pathfinder","this","astar","grid","start","end","solve","START_POS","END_POS","console","log","n1","n2","x","y","open","openAnimationCells","closed","f","g","parent","push","length","sort","a","b","cur","slice","neighbours","getNeighbours","i","cn","clone","JSON","parse","stringify","wall","cc","path","reverse","diagonal","h","heuristic","obj2","nodeEquals","obj","openindex","pos0","pos1","Math","sqrt","node","ret","ret2","concat","Node","props","state","id","class","type","ref","refpass","className","onMouseDown","onMouseEnter","onMouseUp","Component","SideOptions","speedCall","speed","speedValue","speedMax","label","sp","setState","isMenuOpened","sideArrowClass","transitionDuration","effect","position","onClick","handleClick","bind","abs","defaultValue","min","max","onChange","e","speedCallback","target","value","solveClose","floor","BOARD_HEIGHT","BOARD_WIDTH","Board","gridComp","mouseIsPressed","lastPressed","lastSwitched","buttons","ele","current","resettimeout","resetGrid","recursiveDivisionGrid","setTimeout","passage","accessRef","extra","horizontal","makeWall","removePathOpenCurrent","window","clearTimeout","test","solveAstar","animateastar","replace","wipe","firstNonNode","lastNonNode","includes","reset","resetStartEnd","grids","createBlankGrid","name","aStarSolve","createRecursiveMaze","map","row","rowid","item","makeNode","isStartOrEnd","handleGridItemChange","setStartEnd","gridcomp","rowcomp","curref","React","createRef","curnode","handleMouseDown","handleMouseEnter","handleMouseUp","curitem","Infinity","curcomp","width","height","cells","divide","minX","maxX","minY","maxY","animationCells","initial","random","randomNumber","addHWall","addVWall","hole","mergeSort","array","workArray","anims","initialStart","initialEnd","middle","left","right","last","k","j","vals","merge","Bar","arraySize","generateRandomArray","len","forEach","curAnim","index","bars","document","getElementById","info","barOneIdx","barTwoIdx","chosenID","higher","innerText","children","style","split","classList","newHeight","cleanup","barOneStyle","undefined","leftStartID","leftEndID","rightStartID","rightEndID","middleLeft","middleRight","removeLastStep","lastStep","animations","mergeSortArray","shift","animate","arrayCopy","auxArray","animateMergeSort","val","StyledSlider","styled","ReactSlider","StyledThumb","div","Thumb","StyledTrack","Track","onAfterChange","invert","renderTrack","renderThumb","genNewArray","stepAnimateMergeSort","curEle","margin","Sorting","Main","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ce8acad9.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export default class pathfinder {\n    constructor() {\n        this.astar = null\n    }\n    solveAstar(grid, start, end) {\n        this.astar = new astar(start, end, grid)\n        return this.astar.solve()\n    }\n\n\n}\n\nclass astar {\n    constructor(start, end, grid) {\n        this.START_POS = start\n        this.END_POS = end\n        this.grid = grid;\n        console.log(start);\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n    }\n    solve() {\n        let open = []\n        let openAnimationCells = []\n        let closed = []\n        console.log(this.START_POS);\n        let start = this.grid[this.START_POS.y][this.START_POS.x]\n        let end = this.grid[this.END_POS.y][this.END_POS.x]\n        console.log(this.grid);\n        start.f = 0\n        start.g = 0\n        start.start = true\n        end.end = true\n        start.parent = null\n        open.push(start)\n        while (open.length > 0) {\n            open.sort((a, b) => (a.f > b.f) ? 1 : -1)\n\n            if (open.length > 5) {\n                //return\n            }\n            let cur = open[0]\n            open = open.slice(1)\n            let neighbours = this.getNeighbours(cur)\n            for (let i = 0; i < neighbours.length; i++) {\n                let cn = neighbours[i]\n                let clone = JSON.parse(JSON.stringify(cur))\n                cn.parent = clone\n                if (cn.wall) {\n                    continue\n                }\n                // fin conditon\n                if (cn.end) {\n                    console.log(\"finished\");\n                    let cc = cn\n                    let path = []\n                    while (cc != null && !(cc.start)) {\n                        path.push(cc)\n                        cc = cc.parent\n                    }\n                    path.reverse()\n\n                    return [path, openAnimationCells]\n\n\n                }\n                let g = cur.g\n                cn.g = cn.diagonal ? g + 2 : g + 1\n                cn.h = this.heuristic(cn, end)\n                cn.f = cn.g + cn.h\n\n                let obj2 = null\n                let indexclosed = null\n                for (let x = 0; x < closed.length; x++) {\n\n                    if (this.nodeEquals(closed[x], cn)) {\n                        obj2 = closed[x]\n                        indexclosed = x\n                        break\n                    }\n                }\n                if (obj2 != null) {\n                    if (cn.g < obj2.g) {\n                        open.push(cn.g)\n                    }\n                    continue\n                }\n                let obj = null\n                let openindex = null\n                for (let x = 0; x < open.length; x++) {\n\n                    if (this.nodeEquals(open[x], cn)) {\n                        obj = open[x]\n                        openindex = x\n                        break\n                    }\n                }\n                if (obj != null) {\n                    //console.log(\"switched\", this.accessRef(open[openindex]));\n                    if (cn.g < obj.g) {\n                        openAnimationCells.push(cn)\n                        open[openindex] = cn\n                    }\n                    continue\n                }\n                open.push(cn)\n                openAnimationCells.push(cn)\n\n\n\n\n            }\n            closed.push(cur)\n        }\n        return [[], openAnimationCells]\n    }\n    heuristic(pos0, pos1) {\n        var a = pos0.x - pos1.x\n        var b = pos0.y - pos1.y\n\n        return Math.sqrt(a * a + b * b)\n    }\n    getNeighbours(node, diagonal = false) {\n        let grid = this.grid\n        var ret = [];\n        var x = node.y\n        var y = node.x\n\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y]);\n        }\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y]);\n        }\n        if (grid[x][y - 1]) {\n            ret.push(grid[x][y - 1]);\n        }\n        if (grid[x][y + 1]) {\n            ret.push(grid[x][y + 1]);\n        }\n        let ret2 = []\n        if (diagonal) {\n\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret2.push(grid[x + 1][y + 1]);\n            }\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret2.push(grid[x + 1][y - 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret2.push(grid[x - 1][y + 1]);\n            }\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret2.push(grid[x - 1][y - 1]);\n            }\n            for (let i = 0; i < ret2.length; i++) {\n                ret2[i].diagonal = true;\n            }\n        }\n        // for (let x = 0; x < ret.length; x++) {\n        //     ret[x].parent = null\n        // }\n        return ret.concat(ret2);\n    }\n\n}","import React, { Component, createRef } from 'react'\nimport './node.scss'\nexport default class Node extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            x: props.x,\n            y: props.y,\n            id: +props.x + \"|\" + props.y,\n            class: props.type,\n            ref: props.refpass,\n        }\n        \n    }\n    render() {\n        return (\n            <div id={this.state.id} className={this.state.class}\n                ref={this.state.ref}\n                onMouseDown={() => this.props.onMouseDown(this.state.ref,this.state.x,this.state.y)}\n                onMouseEnter={() => this.props.onMouseEnter(this.state.ref,this.state.x,this.state.y)}\n                onMouseUp={() => this.props.onMouseUp(this.state.ref,this.state.x,this.state.y)}>\n            </div>\n        )\n    }\n}\n","\"use strict\";\n\nimport React, { Component } from \"react\";\nimport { OffCanvas, OffCanvasMenu, OffCanvasBody } from \"react-offcanvas\";\nimport './SideOptions.scss'\nexport default class SideOptions extends Component {\n  constructor(props) {\n    super(props)\n    this.solve = props.solve;\n    this.speedCall = props.speed;\n    this.speed = props.speedValue;\n    this.speedMax = props.speedMax;\n    this.label = props.label;\n\n  }\n  speedCallback(sp){\n    this.setState({speed:sp},this.speedCall(sp))\n  }\n  componentWillMount() {\n    // sets the initial state\n    this.setState({\n      isMenuOpened: false,\n      speed:this.speed\n      \n    });\n  }\n\n  render() {\n    let sideArrowClass = `button switch${this.state.isMenuOpened ? \" rightArrow\" : \"\"}`\n    return (\n      <OffCanvas\n        transitionDuration={300}\n        effect={\"push\"}\n        isMenuOpened={this.state.isMenuOpened}\n        position={\"right\"}\n      >\n        <OffCanvasBody\n\n        >\n          <div className=\"open-settings\" onClick={this.handleClick.bind(this)}>\n          \n            <a className={sideArrowClass} >\n              <div className=\"arrow\"></div>\n            </a>\n            \n\n          </div>\n        </OffCanvasBody>\n        <OffCanvasMenu\n          className=\"settings\" \n        >\n\n          <div className=\"speed-slider\">\n            <div className=\"speed-label\">\n              Speed {Math.abs(this.state.speed-this.speedMax)}\n            </div>\n          <input defaultValue={this.state.speed} min={2} max={this.speedMax} type=\"range\" onChange={(e)=>{this.speedCallback(e.target.value)}}/>\n          </div>\n          <div className=\"side-solve\" onClick={this.solveClose.bind(this)} >\n            {this.label}\n              </div>\n\n        </OffCanvasMenu>\n      </OffCanvas>\n    );\n  }\n\n  handleClick() {\n    // toggles the menu opened state\n    this.setState({ isMenuOpened: !this.state.isMenuOpened });\n  }\n  solveClose() {\n    this.setState({ isMenuOpened: false }, this.solve);\n  }\n}","import React, { Component } from 'react'\nimport pathfinder from '../pathfinding.js';\nimport Node from '../Node/Node';\n\nimport './board.scss'\nimport SideOptions from '../../Sidebar/SideOptions.js';\nvar BOARD_WIDTH = 41\nvar BOARD_HEIGHT = 15\nvar START_POS = { x: 2, y: Math.floor(BOARD_HEIGHT / 2) }\nvar END_POS = { x: BOARD_WIDTH - 3, y: Math.floor(BOARD_HEIGHT / 2) }\n\nexport default class Board extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            gridComp: [],\n            mouseIsPressed: false,\n            lastPressed: null,\n            lastSwitched: null,\n\n        }\n        this.pathfinder = new pathfinder()\n        this.speed = 10;\n        this.buttons = true;\n    }\n    speedCallback(sp) {\n        this.speed = sp;\n    }\n    nodeEquals(n1, n2) {\n        if (n1.x === n2.x && n1.y === n2.y) {\n            return true\n        }\n        return false\n    }\n    accessRef(ele) {\n        return this.state.gridComp[ele.y][ele.x].ref.current\n    }\n    createRecursiveMaze() {\n        let resettimeout = this.resetGrid()\n        let grid = this.recursiveDivisionGrid()\n        console.log(grid);\n        setTimeout(() => {\n\n\n            for (let x = 0; x < grid.length; x++) {\n                setTimeout(() => {\n                    if (this.state.grid[grid[x].y][grid[x].x].passage) {\n                        console.log(\"p\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        if (this.state.grid[grid[x].y][grid[x].x].extra) {\n                            console.log(\"e\", this.accessRef(this.state.grid[grid[x].y][grid[x].x]));\n                        }\n                        console.log(this.state.grid[grid[x].y][grid[x].x].horizontal);\n                    } else {\n\n                    }\n                    this.makeWall(grid[x].x, grid[x].y)\n\n\n                }, x * this.speed);\n            }\n        }, resettimeout);\n    }\n    animateRecursiveGrid() {\n        let grid = this.recursiveDivisionGrid()\n        for (let x = 0; x < grid.length; x++) {\n            setTimeout(() => {\n                this.makeWall(grid[x].x, grid[x].y)\n            }, x * (this.speed * 3));\n        }\n    }\n    aStarSolve() {\n        console.log(this.buttons);\n        if(!this.buttons){\n            return;\n        }\n        this.removePathOpenCurrent()\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let test = this.pathfinder.solveAstar(this.state.grid, START_POS, END_POS)\n\n        this.animateastar(test[0], test[1], 5)\n\n    }\n    animateastar(path, open) {\n        for (let x = 0; x < open.length; x++) {\n            setTimeout(() => {\n                this.accessRef(open[x]).className += \" current\"\n                setTimeout(() => {\n\n                    if (open[x - 1]) {\n                        this.accessRef(open[x - 1]).className = this.accessRef(open[x - 1]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x - 1]).className += \" open\"\n                    }\n                    if (x === open.length - 1) {\n                        this.accessRef(open[x]).className = this.accessRef(open[x]).className.replace(\" current\", \"\")\n                        this.accessRef(open[x]).className += \" open\"\n                    }\n                }, 0);\n\n\n\n            }, x * (this.speed * 5));\n        }\n        if (path.length == 0) {\n            setTimeout(() => {\n\n                for (let x = 0; x < open.length; x++) {\n                    setTimeout(() => {\n                        this.accessRef(open[x]).className += \" noPath\"\n                    }, x * (this.speed * 1));\n\n                }\n\n            }, (open.length * (this.speed * 5)));\n        }\n        setTimeout(() => {\n            for (let x = 0; x < path.length; x++) {\n                setTimeout(() => {\n                    console.log(\"test\");\n                    if (!path[x].start && !path[x].end) {\n                        this.accessRef(path[x]).className = \"node path\"\n                    }\n                }, x * (this.speed * 7.5));\n\n            }\n        }, (open.length * (this.speed * 5)) + 100);\n\n\n\n\n\n\n    }\n    resetGrid(wipe = false) {\n        this.buttons = false\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        let firstNonNode = null\n        let lastNonNode = null\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (firstNonNode == null || x < firstNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        firstNonNode = x\n                    }\n                }\n                if (lastNonNode == null || x > lastNonNode) {\n                    if (![\"node start\", \"node end\", \"node\"].includes(this.accessRef(this.state.grid[y][x]).className)) {\n                        lastNonNode = x\n                    }\n                }\n                if (this.state.grid[y][x].wall) {\n                    this.state.grid[y][x].wall = false\n                }\n                if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                    continue\n                }\n                if (!wipe) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                    this.buttons= true;\n                }\n\n            }\n        }\n        if (firstNonNode == null) {\n            firstNonNode = 0\n        }\n        if (lastNonNode == null) {\n            lastNonNode = this.state.grid[0].length - 1\n        }\n        if (wipe) {\n            for (let x = firstNonNode; x <= lastNonNode; x++) {\n\n                // console.log(x);\n                setTimeout(() => {\n                    for (let y = 0; y < this.state.grid.length; y++) {\n\n                        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n                            this.accessRef(this.state.grid[y][x]).className += \" wipe\"\n\n                        } else {\n                            this.accessRef(this.state.grid[y][x]).className = \"node wipe\"\n                        }\n                        setTimeout(() => {\n                            this.accessRef(this.state.grid[y][x]).className = this.accessRef(this.state.grid[y][x]).className.replace(\" wipe\", \"\")\n                        }, 300);\n                    }\n                }, 45 * x);\n            }\n\n            return (45 * this.state.grid[0].length) + 300\n        }\n        return 0\n\n    }\n    removePathOpenCurrent() {\n        for (let y = 0; y < this.state.grid.length; y++) {\n            for (let x = 0; x < this.state.grid[y].length; x++) {\n                if (this.accessRef(this.state.grid[y][x]).className.includes(\"path\") || this.accessRef(this.state.grid[y][x]).className.includes(\"open\") || this.accessRef(this.state.grid[y][x]).className.includes(\"current\")) {\n                    this.accessRef(this.state.grid[y][x]).className = \"node\"\n                }\n            }\n        }\n    }\n    resetStartEnd(reset) {\n\n        // START_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // START_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n\n        // END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        // END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // while (END_POS.x == START_POS.x && START_POS.y == END_POS.y) {\n        //     END_POS.x = this.randomNumber(1, BOARD_WIDTH - 2)\n        //     END_POS.y = this.randomNumber(1, BOARD_HEIGHT - 2)\n        // }\n        if (reset) {\n            this.state.grid[START_POS.y][START_POS.x].start = true\n            this.state.grid[END_POS.y][END_POS.x].end = true\n            this.accessRef(START_POS).className = \"node start\"\n            this.accessRef(END_POS).className = \"node end\"\n        }\n        console.log(START_POS);\n        console.log(END_POS);\n    }\n    componentDidMount() {\n        console.log(new pathfinder().astar);\n        this.resetStartEnd()\n        let grids = this.createBlankGrid()\n        console.log(grids[0]);\n        this.setState({ grid: grids[0], gridComp: grids[1] })\n    }\n    componentWillUnmount(){\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n    }\n    render() {\n        return (\n            <div className=\"container pathfinding\">\n                <div className=\"container2 pathfinding\">\n                    <div className=\"grid-options pathfinding\">\n                        <div class=\"select\">\n                            <select name=\"slct\" id=\"slct\">\n                                <option value=\"AStar\">A* Search</option>\n                            </select>\n                        </div>\n                        <div className=\"header-button\" onClick={() => this.aStarSolve()}><span>Solve</span></div>\n                        <div class=\"select\">\n                            <select name=\"slct\" id=\"slct\">\n                                <option value=\"RecDiv\">Recursive Division</option>\n                            </select>\n                        </div>\n                        <div className=\"header-button\" onClick={() => this.createRecursiveMaze()}><span>Create</span></div>\n                        <div className=\"header-button\" onClick={() => {\n                            setTimeout(() => {\n                                this.buttons = true;\n                                console.log(this.buttons);\n                            }, this.resetGrid(true));\n                        }}><span>RESET GRID</span></div>\n\n                    </div>\n                    <SideOptions solve={() => this.aStarSolve()}\n                        speed={(sp) => { this.speedCallback(sp) }}\n                        speedValue={this.speed}\n                        speedMax = {30}\n                        label=\"Solve\"\n                    >\n                    </SideOptions>\n                </div>\n\n\n\n                <div className=\"grid\">\n                    {this.state.gridComp.map((row, rowid) =>\n                        // <div id={rowid} className=\"row\"> {row.map((item) => (item.node))} </div>\n                        row.map((item) => (item.node))\n                    )\n                    } </div>\n            </div>\n        )\n    }\n    handleGridItemChange(ref, x, y) {\n        if (this.state.grid[y][x].start || this.state.grid[y][x].end) {\n            return\n        }\n        let className = ref.current.className\n        switch (className) {\n            case \"node wall\":\n                this.makeNode(x, y)\n                break;\n            default:\n                this.makeWall(x, y)\n                break;\n        }\n\n\n    }\n    isStartOrEnd(x, y) {\n        //console.log(x, y);\n        return this.state.grid[y][x].start || this.state.grid[y][x].end\n    }\n    makeWall(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = true\n        this.accessRef(this.state.grid[y][x]).className = \"node wall\"\n    }\n    makeNode(x, y) {\n        if (this.isStartOrEnd(x, y)) {\n            return\n        }\n        this.state.grid[y][x].wall = false\n        this.accessRef(this.state.grid[y][x]).className = \"node\"\n    }\n    handleMouseDown(ref, x, y) {\n        if (this.nodeEquals({ x, y }, START_POS)) {\n            console.log(\"start\");\n            this.state.lastPressed = \"start\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        if (this.nodeEquals({ x, y }, END_POS)) {\n            console.log(\"end\");\n            this.state.lastPressed = \"end\"\n            this.state.lastSwitched = { x, y }\n            return\n        }\n        this.setState({ mouseIsPressed: true })\n\n        this.handleGridItemChange(ref, x, y, true)\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    setStartEnd(x, y) {\n        switch (this.state.lastPressed) {\n            case \"start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = { x, y }\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = { x, y }\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n        switch (this.accessRef(this.state.lastSwitched).className) {\n            case \"node start\":\n                this.state.grid[START_POS.y][START_POS.x].start = false\n                START_POS = this.state.lastSwitched\n                this.state.grid[START_POS.y][START_POS.x].start = true\n                break;\n\n            case \"node end\":\n                this.state.grid[END_POS.y][END_POS.x].end = false\n                END_POS = this.state.lastSwitched\n                this.state.grid[END_POS.y][END_POS.x].end = true\n                break;\n        }\n    }\n    handleMouseEnter(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            console.log(x, y);\n            console.log(this.state.lastSwitched);\n            this.accessRef(this.state.lastSwitched).className = this.accessRef({ x, y }).className\n            ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastSwitched = { x, y }\n        }\n        if (!this.state.mouseIsPressed) {\n            return\n        }\n        this.handleGridItemChange(ref, x, y)\n        // ref.current.className.includes(\"wall\") ? ref.current.className = \"node\" : ref.current.className = \"node wall\"\n        // ref.current.className.includes(\"wall\") ? this.state.grid[y][x].wall = true : this.state.grid[y][x].wall = false\n    }\n    handleMouseUp(ref, x, y) {\n        if (this.state.lastPressed != null) {\n            //ref.current.className = \"node \" + this.state.lastPressed\n\n            this.setStartEnd(x, y)\n            this.state.lastPressed = null\n            this.state.lastSwitched = null\n        }\n        this.setState({ mouseIsPressed: false })\n        console.log(\"mouse up\");\n\n    }\n    createBlankGrid() {\n        let grid = [];\n        let gridcomp = []\n        for (let y = 0; y < Math.floor(BOARD_HEIGHT); y++) {\n            let row = [];\n            let rowcomp = []\n            for (let x = 0; x < BOARD_WIDTH; x++) {\n                let curref = React.createRef()\n                let type = this.nodeEquals({ x: x, y: y }, START_POS) ? \" start\" : this.nodeEquals({ x: x, y: y }, END_POS) ? \" end\" : \"\"\n                let curnode = (< Node x={x}\n                    y={y}\n                    mouseIsPressed={this.state.mouseIsPressed}\n                    onMouseDown={\n                        (ref) => this.handleMouseDown(ref, x, y)}\n                    onMouseEnter={\n                        (ref) => this.handleMouseEnter(ref, x, y)}\n                    onMouseUp={\n                        (ref) => this.handleMouseUp(ref, x, y)}\n                    refpass={curref}\n                    type={\"node\" + type}\n                >\n                </Node>)\n                let curitem = {\n                    x: x,\n                    y: y,\n                    f: Infinity,\n                    h: 0,\n                    g: 0,\n                    start: type == \" start\",\n                    end: type == \" end\",\n                    wall: false\n                }\n                row.push(curitem)\n                let curcomp = {\n                    x: x,\n                    y: y,\n                    node: curnode,\n                    ref: curref\n                }\n                rowcomp.push(curcomp)\n            }\n            grid.push(row)\n            gridcomp.push(rowcomp)\n        }\n        let test = []\n        test.push(grid)\n        test.push(gridcomp)\n        return test\n    }\n    recursiveDivisionGrid() {\n\n        let width = this.state.grid[0].length\n        let height = this.state.grid.length\n        let cells = []\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (y == 0 || y == height - 1) {\n                    cells.push({ x, y })\n                    //this.makeWall(x, y)\n                }\n            }\n\n            //this.makeWall(0, y)\n            cells.push({ x: 0, y })\n            //this.makeWall(width - 1, y)\n            cells.push({ x: width - 1, y })\n\n        }\n        return cells.concat(this.divide(true, 2, width - 3, 2, height - 3, [], true))\n\n    }\n    divide(h, minX, maxX, minY, maxY, animationCells = [], initial = false) {\n        console.log(initial);\n        console.log(\"haha\");\n        if (initial) {\n            h = true\n        }\n        if (maxY - minY > maxX - minX || (maxY - minY == maxX - minX) && Math.floor(Math.random() * 2) == 1) {\n            // if (h) {\n            if (maxX - minX < 1) {\n                return animationCells\n            }\n\n            var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2\n            if (initial) {\n                console.log(\"apples\");\n                y = minY + Math.floor((maxY - minX) / 2)\n            }\n            animationCells = animationCells.concat(this.addHWall(minX, maxX, y))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, minY, y - 2))\n            animationCells = animationCells.concat(this.divide(!h, minX, maxX, y + 2, maxY))\n        } else {\n            if (maxY - minY < 1) {\n                return animationCells\n            }\n\n            var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2\n            animationCells = animationCells.concat(this.addVWall(minY, maxY, x))\n\n            animationCells = animationCells.concat(this.divide(!h, minX, x - 2, minY, maxY))\n            animationCells = animationCells.concat(this.divide(!h, x + 2, maxX, minY, maxY))\n        }\n        return animationCells\n\n    }\n    addHWall(minX, maxX, y) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        var hole2 = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1\n        console.log(minX, maxX, hole);\n        hole2 = 999\n        for (var i = minX - 1; i <= maxX + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(i, y)\n                continue\n            }\n            cells.push({ x: i, y: y })\n        }\n        return cells\n    }\n\n    addVWall(minY, maxY, x) {\n        let cells = []\n        var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1\n\n        var hole2 = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\n        console.log(minY, maxY, hole);\n        hole2 = 999\n        for (var i = minY - 1; i <= maxY + 1; i++) {\n            if (i === hole || i === hole2) {\n                this.makeNode(x, i)\n                continue\n            }\n            cells.push({ x: x, y: i })\n        }\n        return cells\n    }\n\n    randomNumber(min, max) {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n}","export function mergeSort(\n    array,\n    start,\n    end,\n    workArray,\n    anims\n) {\n    if (start == end) {\n        return\n    }\n    const initialStart = start\n    const initialEnd = end\n    const middle = Math.floor((start + end) / 2)\n    anims.push({ type: \"split\", left: [start, middle], right: [middle + 1, end], middle: [middle, middle + 1] })//initial split\n    mergeSort(workArray, start, middle, array, anims);\n    mergeSort(workArray, middle + 1, end, array, anims);\n    anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n    merge(array, start, middle, end, workArray, anims);\n}\nfunction merge(\n    array,\n    start,\n    middle,\n    end,\n    workArray,\n    anims\n) {\n\n    let k = start\n    let i = start\n    let j = middle + 1\n    //perform the merge in sort order\n    while (i <= middle && j <= end) {\n        //compare\n        anims.push({ type: \"compare\", vals: [i, j, (workArray[i] <= workArray[j]) ? i : j] })\n        if (workArray[i] <= workArray[j]) {\n            anims.push({ type: \"change\", vals: [k, workArray[i]] });\n            array[k++] = workArray[i++];\n        } else {\n            anims.push({ type: \"change\", vals: [k, workArray[j]] });\n            array[k++] = workArray[j++];\n        }\n    }\n\n\n    //pick up the last element(s)\n    while (i <= middle) {\n        anims.push({ type: \"change\", vals: [k, workArray[i], i] });\n        array[k++] = workArray[i++];\n    }\n    while (j <= end) {\n        anims.push({ type: \"change\", vals: [k, workArray[j], j] });\n        array[k++] = workArray[j++];\n    }\n}","\nimport React, { Component, useRef } from 'react'\nimport './Bar.scss'\nimport { mergeSort } from './Algorithms/topdownmergesort'\nimport ReactSlider from 'react-slider'\nimport styled from 'styled-components';\nimport SideOptions from '../../Sidebar/SideOptions.js'\nexport default class Bar extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { arraySize: 31, array: [], speed: 200 }\n    }\n    componentDidMount() {\n        this.setState({ array: this.generateRandomArray() })\n    }\n    generateRandomArray(len = this.state.arraySize, min = 1, max = 100) {\n        let array = []\n        for (let x = 0; x < len; x++) {\n            array.push(Math.floor(Math.random() * (max - min + 1)) + min)\n        }\n        console.log(array);\n        return array\n    }\n    shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n    animateMergeSort(anims) {\n        let speed = this.state.speed\n        console.log(\"speed \", speed);\n        anims.forEach((curAnim, index) => {\n            setTimeout(() => {\n                const bars = document.getElementById(\"barContainer\")\n                const info = document.getElementById(\"info\")\n                switch (curAnim.type) {\n\n                    case \"compare\":\n                        {\n\n                            const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                            const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n\n                            info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                            info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n\n\n                            //console.log(bars);\n                            bars.children[barOneIdx].classList = \"bar compare\"\n                            bars.children[barTwoIdx].classList = \"bar compare\"\n                            bars.children[chosenID].classList = \"bar chosen\"\n\n\n                            break;\n                        }\n                    case \"change\":\n                        const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                        console.log(curAnim.vals);\n                        const barOneStyle = bars.children[barOneIdx].style;\n                        //bars.children[barOneIdx].innerText = newHeight\n                        info.innerText = `setting value`\n                        if (cleanup != undefined) {\n                            info.innerText += `\\none side is empty, adding larger elements at end`\n                        }\n                        barOneStyle.height = `${newHeight}%`;\n                        bars.children[barOneIdx].classList = \"bar sorted\"\n\n                        break;\n                    case \"split\": {\n                        const [leftStartID, leftEndID] = curAnim.left\n                        const [rightStartID, rightEndID] = curAnim.right\n                        const [middleLeft, middleRight] = curAnim.middle\n                        info.innerText = `splitting`\n                        console.log(curAnim.middle);\n\n                        console.log(bars.children[middleLeft], bars.children[middleRight]);\n\n                        for (let x = leftStartID; x <= leftEndID; x++) {\n                            bars.children[x].classList = \"bar left\"\n                        }\n                        for (let x = rightStartID; x <= rightEndID; x++) {\n                            bars.children[x].classList = \"bar right\"\n                        }\n                        bars.children[middleLeft].classList += \" split-left\"\n                        bars.children[middleRight].classList += \" split-right\"\n                    }\n                        break;\n                    case \"merge\": {\n                        //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n\n                    }\n                }\n                setTimeout(() => {\n                    this.removeLastStep(curAnim)\n                }, speed / 2);\n            }, index * speed);\n\n        })\n    }\n    removeLastStep(curAnim = this.lastStep) {\n        const bars = document.getElementById(\"barContainer\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n                    bars.children[barOneIdx].classList = \"bar\"\n                    bars.children[barTwoIdx].classList.value = \"bar\"\n                    bars.children[chosenID].classList = \"bar\"\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight] = curAnim.vals;\n\n                bars.children[barOneIdx].classList = \"bar\"\n                break;\n            case \"split\": {\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                bars.children[middleLeft].classList = \"bar\"\n                bars.children[middleRight].classList = \"bar\"\n\n                for (let x = leftStartID; x < leftEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar\"\n                }\n\n\n            }\n\n        }\n    }\n    stepAnimateMergeSort() {\n        if (!this.animations || this.animations == null) {\n            this.animations = this.mergeSortArray()\n        }\n        if (this.lastStep) {\n            this.removeLastStep()\n        }\n        let curAnim = this.animations.shift()\n        this.lastStep = curAnim\n        const bars = document.getElementById(\"barContainer\")\n        const info = document.getElementById(\"info\")\n        switch (curAnim.type) {\n\n            case \"compare\":\n                {\n\n                    const [barOneIdx, barTwoIdx, chosenID] = curAnim.vals;\n                    const higher = barTwoIdx == chosenID ? barOneIdx : barTwoIdx\n\n                    info.innerText = `comparing ${bars.children[barOneIdx].style.height.split(\"%\")[0]} and ${bars.children[barTwoIdx].style.height.split(\"%\")[0]}`\n                    info.innerText += `\\n${bars.children[chosenID].style.height.split(\"%\")[0]} is less than ${bars.children[higher].style.height.split(\"%\")[0]}`\n\n\n                    //console.log(bars);\n                    bars.children[barOneIdx].classList = \"bar compare\"\n                    bars.children[barTwoIdx].classList = \"bar compare\"\n                    bars.children[chosenID].classList = \"bar chosen\"\n\n\n                    break;\n                }\n            case \"change\":\n                const [barOneIdx, newHeight, cleanup] = curAnim.vals;\n                console.log(curAnim.vals);\n                const barOneStyle = bars.children[barOneIdx].style;\n                //bars.children[barOneIdx].innerText = newHeight\n                info.innerText = `setting value`\n                if (cleanup != undefined) {\n                    info.innerText += `\\none side is empty, adding larger elements at end`\n                }\n                barOneStyle.height = `${newHeight}%`;\n                bars.children[barOneIdx].classList = \"bar sorted\"\n\n                break;\n            case \"split\": {\n                //anims.push({ type: \"split\", left: [startIdx, middleIdx], right: [middleIdx + 1, endIdx] })\n                const [leftStartID, leftEndID] = curAnim.left\n                const [rightStartID, rightEndID] = curAnim.right\n                const [middleLeft, middleRight] = curAnim.middle\n                info.innerText = `splitting`\n                console.log(curAnim.middle);\n\n                console.log(bars.children[middleLeft], bars.children[middleRight]);\n\n                for (let x = leftStartID; x <= leftEndID; x++) {\n                    bars.children[x].classList = \"bar left\"\n                }\n                for (let x = rightStartID; x <= rightEndID; x++) {\n                    bars.children[x].classList = \"bar right\"\n                }\n                bars.children[middleLeft].classList += \" split-left\"\n                bars.children[middleRight].classList += \" split-right\"\n            }\n                break;\n            case \"merge\": {\n                //anims.push({ type: \"merge\", start: start, end : end, last: (initialStart == start && initialEnd == end) })// TODO: add last merge checking\n\n            }\n        }\n    }\n    mergeSortArray(animate = false) {\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        const anims = []\n        let arrayCopy = this.state.array.slice()\n        const auxArray = arrayCopy.slice()\n        mergeSort(arrayCopy, 0, arrayCopy.length - 1, auxArray, anims)\n        console.log(anims);\n        console.log(arrayCopy);\n        console.log(auxArray);\n        if (animate) {\n            this.animateMergeSort(anims)\n        }\n        return anims\n\n    }\n\n    genNewArray(val = 11) {\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n        this.setState({ array: this.generateRandomArray(val) }, () => this.setState({ arraySize: val },()=>{let info = document.getElementById(\"info\"); info.innerText=\"info\";let bars = document.getElementById(\"barContainer\"); for(let x =0; x< bars.children.length-3; x++){bars.children[x].classList=\"bar\";}}))\n    }\n    createStyledSliders() {\n        const StyledSlider = styled(ReactSlider)`\n        width: 25%;\n        height: 25px;\n    `;\n\n        const StyledThumb = styled.div`\n        height: 25px;\n        line-height: 25px;\n        width: 25px;\n        text-align: center;\n        background-color: #000;\n        color: #fff;\n        border-radius: 50%;\n        cursor: grab;\n    `;\n\n        const Thumb = (props, state) => <StyledThumb {...props}>{props.label}</StyledThumb>;\n\n        const StyledTrack = styled.div`\n        top: 0;\n        bottom: 0;\n        background: ${props => props.index === 2 ? '' : props.index === 1 ? '#0f0' : '#f00'};\n        border-radius: 999px;\n    `;\n        const Track = (props, state) => <StyledTrack {...props} index={state.index} />;\n        return (\n            <div>\n                <StyledSlider\n                    onAfterChange={(val) => this.setState({ speed: val })}\n                    min={1}\n                    max={500}\n                    invert={true}\n                    defaultValue={this.state.speed}\n                    renderTrack={Track}\n                    renderThumb={Thumb}\n                />\n                <StyledSlider\n                    onAfterChange={(val) => this.genNewArray(val)}\n                    min={1}\n                    max={500}\n                    defaultValue={this.state.arraySize}\n                    renderTrack={Track}\n                    renderThumb={Thumb}\n                />\n            </div>\n        )\n    }\n    speedCallback(sp) {\n        this.setState({ speed: sp })\n\n    }\n    componentWillUnmount(){\n        var id = window.setTimeout(function () { }, 0);\n        while (id--) {\n            window.clearTimeout(id);\n            // will do nothing if no timeout with id is present\n        }\n    }\n    render() {\n        return (\n        \n                <div className=\"container sorting\">\n                    <div className=\"container2 sorting\">\n                        <div className=\"grid-options sorting\">\n                            <div class=\"select\">\n                                <select name=\"slct\" id=\"slct\">\n                                    <option value=\"AStar\">Top-Down Merge Sort</option>\n                                </select>\n                            </div>\n                            <div className=\"header-button\" onClick={() => this.mergeSortArray(true)}><span>Sort</span></div>\n                            <div className=\"header-button\" onClick={() => this.stepAnimateMergeSort()}> <span>Step</span></div>\n                            <div className=\"header-button\" onClick={() => this.genNewArray(this.state.arraySize)}><span>Random</span></div>\n                            <div className=\"size-slider\">\n                                <div className=\"size-label\">\n                                    Size:  {this.state.arraySize}\n                                </div>\n                                <input className=\"size\" defaultValue={this.state.arraySize} min={5} max={500} type=\"range\" onChange={(e) => { this.genNewArray(e.target.value)}} />\n                            </div>\n                        </div>\n                        <SideOptions solve={() => this.mergeSortArray(true)}\n                            speed={(sp) => { this.speedCallback(sp) }}\n                            speedValue={this.state.speed}\n                            speedMax={200}\n                            label =\"Sort\"\n                        >\n                        </SideOptions>\n                    </div>\n                \n                <div className=\"barContainer\" id=\"barContainer\">\n                    {this.state.array.map((curEle) => { return <div ref={curEle.ref} className=\"bar\" style={{ height: `${curEle}%`, width: `${99 / this.state.array.length}vw`, margin: `${(99 / this.state.array.length) / 50}vw` }}></div> })}\n                </div>\n                {/* <button onClick={() => this.mergeSortArray(true)}>\n                    sort\n            </button>\n                <button onClick={() => this.genNewArray(this.state.arraySize)}>\n                    random\n            </button>\n                <button onClick={() => this.stepAnimateMergeSort()}>\n                    step\n            </button>\n                 */}\n                <div id=\"info\">\n                    info\n            </div>\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport Bar from './Bar/Bar'\n\nexport default class Sorting extends Component {\n    render() {\n        return (\n            <Bar></Bar>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport Board from './Pathfinding/Board/Board'\nimport { Tab, TabPanel, Tabs, TabList } from 'react-tabs';\nimport 'react-tabs/style/react-tabs.css';\nimport Sorting from './Sorting/Sorting';\nimport './reset.css'\nimport './main.scss'\nexport default class Main extends Component {\n    render() {\n        return (\n            <Tabs className=\"tabs-container\"> \n            <TabList>\n                <Tab>Pathfinding </Tab>\n                <Tab>Sorting </Tab>\n            </TabList>\n            <TabPanel>\n            <Board></Board>\n            </TabPanel>\n            <TabPanel>\n                <Sorting></Sorting>\n            </TabPanel>\n        </Tabs>\n\n        )\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport Main from './main';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Main></Main>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}